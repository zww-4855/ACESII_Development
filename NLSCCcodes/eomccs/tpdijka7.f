
      SUBROUTINE TPDIJKA7(ICORE,MAXCOR,IUHF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,DISSYG,DISSYH,DISSYH1,DISSYH2,POP,VRT
      DIMENSION ICORE(MAXCOR)
      DIMENSION I0R(2),IOFFRR(8,2),IOFFGG(8)
C
C CALCULATION OF THE SIXTH IJKA CONTRIBUTION TO
C THE EOM-CCSD TWO-PARTICLE DENSITY MATRIX
C
C  G(IJ,KA) = - 1/2 P(IJ) H(KF,IA) R(J,F)
C
CEND 
C
C CODED JG SEPTEMBER/93
C
      COMMON/STATSYM/IRREPX
      COMMON/SYMINF/NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
C
      DATA AZERO,HALFM,ONE /0.D0,-0.5D0,1.0D0/

C READ IN T1 AND R1 AMPLITUDES
C
      I0R(1)=1
      I0R(2)=I0R(1)+IRPDPD(IRREPX,9)*IINTFP*IUHF
      ISTART=I0R(2)+IRPDPD(IRREPX,10)*IINTFP
C
      CALL GETLST(ICORE(I0R(1)),1,1,1,3,490)
      IF(IUHF.EQ.1) THEN
       CALL GETLST(ICORE(I0R(2)),1,1,1,4,490)
      ENDIF
C
      DO 2 ISPIN=1,1+IUHF
       IOFF=0
       DO 1 IRREPR=1,NIRREP
        IRREPL=DIRPRD(IRREPR,IRREPX)
        IOFFRR(IRREPR,ISPIN)=IOFF
        IOFF=IOFF+IINTFP*POP(IRREPR,ISPIN)*VRT(IRREPL,ISPIN)
1      CONTINUE 
2     CONTINUE
      IF(IUHF.EQ.0) CALL ICOPY(8,IOFFRR(1,1),1,IOFFRR(1,2),1)
C
C LOOP OVER SPIN CASES
C
      IF(IUHF.NE.0) THEN
C
       DO 1000 ISPIN=1,1+IUHF
C
C AA AND BB SPIN CASES
C
        LISTH=413+ISPIN
        LISTG=106+ISPIN
C
        DO 100 IRREPR=1,NIRREP
C
         IRREPL=DIRPRD(IRREPX,IRREPR)
C
         NUMSYH=IRPDPD(IRREPR,ISYTYP(2,LISTH))
         DISSYH=IRPDPD(IRREPL,ISYTYP(1,LISTH))
         NUMSYG=IRPDPD(IRREPR,ISYTYP(2,LISTG))
         DISSYG=IRPDPD(IRREPR,ISYTYP(1,LISTG))
         NOCCSQ=IRPDPD(IRREPR,20+ISPIN) 
C
         IOFF=0
         DO 90 IRREPRR=1,NIRREP
          IRREPRL=DIRPRD(IRREPRR,IRREPR)
          IOFFGG(IRREPRR)=IOFF
          IOFF=IOFF+IINTFP*NUMSYG*
     &               POP(IRREPRR,ISPIN)*POP(IRREPRL,ISPIN) 
90       CONTINUE
C
         I000=ISTART
         I010=I000+IINTFP*NUMSYG*NOCCSQ
         ITMP=I010+IINTFP*MAX(NUMSYH*DISSYH,NUMSYG*DISSYG)
         IEND=ITMP+3*IINTFP*MAX(NUMSYH,DISSYH,NUMSYG,DISSYG)
         IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA7',IEND,MAXCOR)
C
C GET TRANSPOSED H INTERMEDIATES
C
         CALL GETTRN(ICORE(I010),ICORE(ITMP),DISSYH,
     &                NUMSYH,1,IRREPR,LISTH)
C
C ZERO G ARRAY
C
         CALL ZERO(ICORE(I000),NUMSYG*NOCCSQ)
C
C TRANSPOSE THE LAST TWO INDICES
C
         CALL SYMTR1(IRREPL,VRT(1,ISPIN),POP(1,ISPIN),
     &               NUMSYH,ICORE(I010),ICORE(ITMP),
     &               ICORE(ITMP+IINTFP*NUMSYH),
     &               ICORE(ITMP+2*IINTFP*NUMSYH))
C
C  LOOP OVER IRREPS OF F AND MULTIPLY
C
         IOFFH=0
C
         DO 101 IRREPE=1,NIRREP
C
C  GET POPULATIONS
C
          IRREPJ=DIRPRD(IRREPE,IRREPX)
          IRREPI=DIRPRD(IRREPE,IRREPL)
          NVRTJ=VRT(IRREPE,ISPIN)
          NOCCJ=POP(IRREPJ,ISPIN)
          NOCCI=POP(IRREPI,ISPIN)
C
          IOFFR=IOFFRR(IRREPJ,ISPIN)
          IOFFG=IOFFGG(IRREPJ)
C
C IF ONE OF THE POPULATIONS IS ZERO, SKIP MULTIPLICATION
C
          IF(MIN(NVRTJ,NOCCI,NOCCJ).NE.0) THEN
C
           CALL XGEMM('N','N',NUMSYH*NOCCI,NOCCJ,NVRTJ,HALFM,
     &                ICORE(I010+IOFFH),NUMSYH*NOCCI,
     &                ICORE(I0R(ISPIN)+IOFFR),NVRTJ,AZERO,
     &                ICORE(I000+IOFFG),NUMSYG*NOCCI)
C
          ENDIF
C
C UPDATE OFFSETS
C
          IOFFH=IOFFH+IINTFP*NUMSYH*NOCCI*NVRTJ
C
101      CONTINUE
C
C ANTISYMMETRIZE G IN THE LAST TWO INDICES    : A,K ; I<J
C
         CALL ASSYM(IRREPR,POP(1,ISPIN),NUMSYG,NUMSYG,ICORE(I010),
     &              ICORE(I000))
C
C TRANSPOSE THE WHOLE G MATRIX : --> I<J ; A,K
C
         CALL TRANSP(ICORE(I010),ICORE(I000),DISSYG,NUMSYG)
C
C  TRANPOSE LAST TWO INDICES IN G --> I<J ; K,A
C
         CALL SYMTR1(IRREPR,VRT(1,ISPIN),POP(1,ISPIN),DISSYG,
     &               ICORE(I000),ICORE(ITMP),
     &               ICORE(ITMP+IINTFP*DISSYG),
     &               ICORE(ITMP+2*IINTFP*DISSYG))
C
C  SAVE G ON DISK
C
          call checksum('tpdijka7',icore(i010),numsyg*dissyg,s)
         CALL GETLST(ICORE(I010),1,NUMSYG,1,IRREPR,LISTG)
         CALL SAXPY (NUMSYG*DISSYG,ONE,ICORE(I010),1,ICORE(I000),1)
         CALL PUTLST(ICORE(I000),1,NUMSYG,1,IRREPR,LISTG)
C
100     CONTINUE
C
1000   CONTINUE
C
      ENDIF
C
C ABAB AND BABA SPIN CASES
C
      DO 2000 ISPIN=1,1+IUHF
C
       LISTG=111-ISPIN
       LISTH1=415+ISPIN
       LISTH2=419-ISPIN+IUHF
C
       DO 1100 IRREPR=1,NIRREP
C
        IRREPL=DIRPRD(IRREPX,IRREPR)
C
        NUMSYH1=IRPDPD(IRREPR,ISYTYP(2,LISTH1))
        DISSYH1=IRPDPD(IRREPL,ISYTYP(1,LISTH1))
        NUMSYH2=IRPDPD(IRREPR,ISYTYP(2,LISTH2))
        DISSYH2=IRPDPD(IRREPL,ISYTYP(1,LISTH2))
        NUMSYG=IRPDPD(IRREPR,ISYTYP(2,LISTG))
        DISSYG=IRPDPD(IRREPR,ISYTYP(1,LISTG))
C
        IOFF=0
        DO 1090 IRREPRR=1,NIRREP
         IRREPRL=DIRPRD(IRREPRR,IRREPR)
         IOFFGG(IRREPRR)=IOFF
         IOFF=IOFF+IINTFP*NUMSYG*POP(IRREPRR,ISPIN)*
     &                           POP(IRREPRL,3-ISPIN) 
1090    CONTINUE  
C
        I000=ISTART
        I010=I000+IINTFP*NUMSYG*DISSYG
        ITMP=I010+IINTFP*MAX(DISSYG*NUMSYG,DISSYH1*NUMSYH1,
     &                       DISSYH2*NUMSYH2)
C
        IF(ITMP.GE.MAXCOR) CALL INSMEM('TPDIJKA7',ITMP,MAXCOR)
C
        CALL GETTRN(ICORE(I010),ICORE(ITMP),DISSYH1,NUMSYH1,
     &              1,IRREPR,LISTH1)

        CALL ZERO(ICORE(I000),NUMSYG*DISSYG)

        CALL SYMTR1(IRREPL,VRT(1,ISPIN),POP(1,3-ISPIN),
     &              NUMSYH1,ICORE(I010),ICORE(ITMP),
     &              ICORE(ITMP+IINTFP*NUMSYH1),
     &              ICORE(ITMP+2*IINTFP*NUMSYH1))
C
C  LOOP OVER IRREPS OF F AND MULTIPLY WITH T1A
C
        IOFFH=0
C
        DO 1101 IRREPE=1,NIRREP
C
C  GET POPULATIONS
C
         IRREPJ=DIRPRD(IRREPE,IRREPX)
         IRREPI=DIRPRD(IRREPE,IRREPL)
         NVRTJ=VRT(IRREPE,ISPIN)
         NOCCJ=POP(IRREPJ,ISPIN)
         NOCCI=POP(IRREPI,3-ISPIN)
C
         IOFFR=IOFFRR(IRREPJ,ISPIN)
         IOFFG=IOFFGG(IRREPJ)
C
C IF ONE OF THE POPULATIONS IS ZERO, SKIP MULTIPLICATION
C
         IF(MIN(NVRTJ,NOCCI,NOCCJ).NE.0) THEN
C
          CALL XGEMM('N','N',NUMSYH1*NOCCI,NOCCJ,NVRTJ,HALFM,
     &               ICORE(I010+IOFFH),NUMSYH1*NOCCI,
     &               ICORE(I0R(ISPIN)+IOFFR),NVRTJ,AZERO,
     &               ICORE(I000+IOFFG),NUMSYG*NOCCI)
         ENDIF
C
C UPDATE OFFSETS
C
         IOFFH=IOFFH+IINTFP*NUMSYH1*NOCCI*NVRTJ
C
1101    CONTINUE
C
C TRANSPOSE THE G LIST FOR SECOND CONTRACTION :    a,K ; j,I --> a,K ; I,j
C
        CALL SYMTR1(IRREPR,POP(1,3-ISPIN),POP(1,ISPIN),NUMSYG,
     &              ICORE(I000),ICORE(ITMP),
     &              ICORE(ITMP+IINTFP*NUMSYG),
     &              ICORE(ITMP+2*IINTFP*NUMSYG))
C
        CALL GETTRN(ICORE(I010),ICORE(ITMP),DISSYH2,NUMSYH2,
     &              1,IRREPR,LISTH2)
C
C TRANPOSE THE LAST TWO INDICES OF H4 : a,K ; f,I  ---> a,K ; I,f
C
        CALL SYMTR1(IRREPL,VRT(1,3-ISPIN),POP(1,ISPIN),NUMSYH2,
     &              ICORE(I010),ICORE(ITMP),
     &              ICORE(ITMP+IINTFP*NUMSYH2),
     &              ICORE(ITMP+2*IINTFP*NUMSYH2))
C
C PERFORM MULTIPLICATION WITH T1B
C
        IOFF=0
        DO 1190 IRREPRR=1,NIRREP
         IRREPRL=DIRPRD(IRREPRR,IRREPR)
         IOFFGG(IRREPRR)=IOFF
         IOFF=IOFF+IINTFP*NUMSYG*POP(IRREPRR,3-ISPIN)*
     &                           POP(IRREPRL,ISPIN)
1190    CONTINUE 
C
        IOFFH=0
C
        DO 1200 IRREPE=1,NIRREP
C
C  GET POPULATIONS FOR MULTIPLICATION
C
         IRREPJ=DIRPRD(IRREPE,IRREPX)
         IRREPI=DIRPRD(IRREPL,IRREPE)
         NVRTJ=VRT(IRREPE,3-ISPIN)
         NOCCJ=POP(IRREPJ,3-ISPIN)
         NOCCI=POP(IRREPI,ISPIN)
C 
         IOFFR=IOFFRR(IRREPJ,3-ISPIN)
         IOFFG=IOFFGG(IRREPJ)
C
C  IF ONE OF THE POPULATIONS IS ZERO, SKIP THE MULTIPLICATION
C
         IF(MIN(NOCCI,NOCCJ,NVRTJ).NE.0) THEN
C
          CALL XGEMM('N','N',NUMSYH2*NOCCI,NOCCJ,NVRTJ,HALFM,
     &               ICORE(I010+IOFFH),NUMSYH2*NOCCI,
     &               ICORE(I0R(3-ISPIN)+IOFFR),NVRTJ,
     &               ONE,ICORE(I000+IOFFG),NUMSYG*NOCCI)
C
         ENDIF
C
C   UPDATE OFFSETS
C
         IOFFH=IOFFH+IINTFP*NUMSYH2*NOCCI*NVRTJ
C
1200    CONTINUE
C
C TRANSPOSE THE WHOLE G MATRIX : a,K ; I,j  -- --> I,j ; a,K
C
        IF(ISPIN.EQ.2) THEN
         CALL SYMTR1(IRREPR,POP(1,ISPIN),POP(1,3-ISPIN),
     &               NUMSYG,ICORE(I000),ICORE(ITMP),
     &               ICORE(ITMP+IINTFP*NUMSYG),
     &               ICORE(ITMP+2*IINTFP*NUMSYG))
        ENDIF
C  
        CALL TRANSP(ICORE(I000),ICORE(I010),DISSYG,NUMSYG)
C
C TRANPOSE LAST TWO INDICES IN G --> I,j ; K,a, BUT ONLY FOR ISPIN=1
C
        IF(ISPIN.EQ.1) THEN
         CALL SYMTR1(IRREPR,VRT(1,3-ISPIN),POP(1,ISPIN),DISSYG,
     &               ICORE(I010),ICORE(ITMP),
     &               ICORE(ITMP+IINTFP*DISSYG),
     &               ICORE(ITMP+2*IINTFP*DISSYG))
        ENDIF
C
C SAVE G ON DISK
C
        call checksum('tpdijka7',icore(i010),numsyg*dissyg,s)
        CALL GETLST(ICORE(I000),1,NUMSYG,1,IRREPR,LISTG)
        CALL SAXPY (NUMSYG*DISSYG,ONE,ICORE(I000),1,ICORE(I010),1)
        CALL PUTLST(ICORE(I010),1,NUMSYG,1,IRREPR,LISTG)
C
1100   CONTINUE
C
2000  CONTINUE
C
C ALL DONE, RETURN
C
      TWO=0.D0
      if(iuhf.eq.0) then
       call checkgam1(icore,10,110,two,iuhf,2,pop)
      endif
      IF(IUHF.EQ.1) THEN
       CALL CHECKGAM(ICORE,10,110,TWO)
       CALL CHECKGAM(ICORE,7,107,TWO)
       CALL CHECKGAM(ICORE,8,108,TWO)
       CALL CHECKGAM(ICORE,9,109,TWO)
      ENDIF
C
      RETURN
      END
