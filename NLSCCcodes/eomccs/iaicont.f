      SUBROUTINE IAICONT(ICORE,MAXCOR,IUHF)
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION ONE,ZILCH,HALF
      DIMENSION ICORE(MAXCOR)
      DIMENSION I0T(2),I0R(2),I0I(2)
C
C CALCULATES CONTRIBUTION OF G(AB,CD) TO THE VIRTUAL-OCCUPIED
C INTERMEDIATE WITHOUT EXPLICIT CONSTRUCTION OR STORAGE OF
C G(AB,CD).
C
C  I(ai) <= G(af,eg)*<if||eg>
C
C WHERE
C
C            = [RMOD(af,mn)*L(eg,mn)+RMOD(eg,mn)*L(af,mn)]*<bf||eg>
C
C
C (RMOD IS THE USUAL R VECTOR PLUS A DTAU CONTRIBUTION
C
CEND 
C
C CODED JFS DECEMBER/93 DURING JG's VISIT!
C
      COMMON/STATSYM/IRREPX
      COMMON/SYMINF/NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
C
      DATA ZILCH,ONE,HALF /0.D0,1.D0,0.5D0/
C
C READ IN T1 AND R1 AMPLITUDES AND MAKE SPACE FOR THE I(AB)
C INTERMEDIATES
C
      I0T(1)=1
      I0T(2)=I0T(1)+IRPDPD(1,9)*IINTFP*IUHF
      I0R(1)=I0T(2)+IRPDPD(1,10)*IINTFP
      I0R(2)=I0R(1)+IRPDPD(IRREPX,9)*IINTFP*IUHF
      I0I(1)=I0R(2)+IRPDPD(IRREPX,10)*IINTFP
      I0I(2)=I0I(1)+IRPDPD(1,9)*IINTFP*IUHF
      ISTART=I0I(2)+IRPDPD(1,10)*IINTFP
C
      CALL GETLST(ICORE(I0T(1)),1,1,1,1,90)
      CALL GETLST(ICORE(I0R(1)),1,1,1,3,490)
      CALL ZERO  (ICORE(I0I(1)),NT(1))
      IF(IUHF.EQ.1) THEN
       CALL GETLST(ICORE(I0T(2)),1,1,1,2,90)
       CALL GETLST(ICORE(I0R(2)),1,1,1,4,490)
       CALL ZERO  (ICORE(I0I(2)),NT(2))
      ENDIF
C
C LOOP OVER SPIN CASES
C
      DO 10 ISPIN=4,4-3*IUHF,-1
       LISTL=443+MIN(ISPIN,3)
       LISTR=460+MIN(ISPIN,3)
       LISTW=26+ISPIN
       DO 100 IRREP1=1,NIRREP
        IRREP2=DIRPRD(IRREP1,IRREPX)
        IRREPW=IRREP2
        DISSYL=IRPDPD(IRREP2,ISYTYP(1,LISTL))
        NUMDSL=IRPDPD(IRREP1,ISYTYP(2,LISTL))
        DISSYR=IRPDPD(IRREP2,ISYTYP(1,LISTR))
        NUMDSR=IRPDPD(IRREP1,ISYTYP(2,LISTR))
        DISSYW=IRPDPD(IRREP2,ISYTYP(1,LISTW))
        NUMDSW=IRPDPD(IRREP2,ISYTYP(2,LISTW))
        DISSYQ=IRPDPD(IRREP1,ISYTYP(1,6+ISPIN))
        NUMDSQ=IRPDPD(IRREP2,ISYTYP(2,26+ISPIN))
        IF(ISPIN.LE.2)THEN
         NVRTSQ=IRPDPD(IRREP2,18+ISPIN)
        ELSE
         NVRTSQ=DISSYL
        ENDIF
        MAXT=MAX(DISSYL,DISSYR,DISSYQ,DISSYW,
     &           NUMDSL,NUMDSR,NUMDSQ,NUMDSW,
     &           NVRTSQ)
        I0Q1=ISTART
        I0Q2=I0Q1+IINTFP*DISSYQ*NUMDSQ
        I000=I0Q2+IINTFP*DISSYQ*NUMDSQ
        I010=I000+IINTFP*MAX(NVRTSQ,DISSYL)*NUMDSL
        I020=I010+IINTFP*MAX(NVRTSQ,DISSYR)*NUMDSR
        ITMP1=I020
        ITMP2=ITMP1+IINTFP*MAXT
        ITMP3=ITMP2+IINTFP*MAXT
        CALL GETLST(ICORE(I000),1,NUMDSL,1,IRREP1,LISTL)
        IF(IUHF.EQ.0)THEN
         CALL SPINAD1(IRREP1,POP(1,1),DISSYL,ICORE(I000),
     &                ICORE(ITMP1),ICORE(ITMP2))
        ENDIF 
        CALL GETLST(ICORE(I010),1,NUMDSR,1,IRREP1,LISTR)
        IF(ISPIN.LE.2)THEN
         CALL DTAU(IRREP2,IRREP1,1,IRREPX,ICORE(I010),
     &             ICORE(I0T(ISPIN)),ICORE(I0T(ISPIN)),
     &             ICORE(I0R(ISPIN)),ICORE(I0R(ISPIN)),ISPIN,ONE)
        ELSE
         CALL DTAU(IRREP2,IRREP1,1,IRREPX,ICORE(I010),
     &             ICORE(I0T(1)),ICORE(I0T(2)),
     &             ICORE(I0R(1)),ICORE(I0R(2)),3,ONE)
        ENDIF
        IFIRST =I000
        ISECOND=I010
C
C FIRST CONTRACT X(F<G,M<N) WITH W(F<G,EI)
C
C
C         Q1(mn,ei) = L+(fg,mn) *W(fg,ei)
C         Q2(mn,ei) = R+(fg,mn) *W(fg,ei)
C
C PRODUCES Q(M<N,EI) => ISPIN=1
C          Q(m<n,ei) => ISPIN=2
C          Q(Mn,Ie ) => ISPIN=3
C          Q(Mn,Ei ) => ISPIN=4
C
        CORLFT=MAXCOR-I020+1
        IF(DISSYW.NE.0)THEN
         NINCOR=CORLFT/(DISSYW*IINTFP)
        ELSE
         NINCOR=NUMDSW
        ENDIF
        NLEFT =NUMDSW
        NFIRST=1
        IOFFQ1=I0Q1
        IOFFQ2=I0Q2
        IOFF1 =IFIRST
        IOFF2 =ISECOND
1       NBATCH=MIN(NLEFT,NINCOR)
        CALL GETLST(ICORE(I020),NFIRST,NBATCH,1,IRREPW,LISTW)
        CALL XGEMM('T','N',NUMDSL,NBATCH,DISSYW,ONE,ICORE(IOFF1),
     &             DISSYL,ICORE(I020),DISSYW,ZILCH,ICORE(IOFFQ1),
     &             NUMDSL)
        CALL XGEMM('T','N',NUMDSL,NBATCH,DISSYW,ONE,ICORE(IOFF2),
     &             DISSYL,ICORE(I020),DISSYW,ZILCH,ICORE(IOFFQ2),
     &             NUMDSL)
        IOFFQ1=IOFFQ1+IINTFP*NBATCH*DISSYQ
        IOFFQ2=IOFFQ2+IINTFP*NBATCH*DISSYQ
        NLEFT=NLEFT-NBATCH
        NFIRST=NFIRST+NBATCH
        IF(NLEFT.NE.0)GOTO 1
C
C        I(ai) <= R(mn,ea)*Q1(mn,ei) + L(mn,ea)*Q2(mn,ei) [ISPIN=1,2]
C 
        CALL TRANSP(ICORE(I000),ICORE(I020),NUMDSL,DISSYL)
c YAU : old
c       CALL ICOPY(NUMDSL*DISSYL*IINTFP,ICORE(I020),1,ICORE(I000),1)
c YAU : new
        CALL DCOPY(NUMDSL*DISSYL,ICORE(I020),1,ICORE(I000),1)
c YAU : end
        CALL TRANSP(ICORE(I010),ICORE(I020),NUMDSL,DISSYL)
c YAU : old
c       CALL ICOPY(NUMDSL*DISSYL*IINTFP,ICORE(I020),1,ICORE(I010),1)
c YAU : new
        CALL DCOPY(NUMDSL*DISSYL,ICORE(I020),1,ICORE(I010),1)
c YAU : end
        IFIRST =I010
        ISECOND=I000
C
        IF(ISPIN.LE.2)THEN
C
C EXPAND RHS OF R AND L
C
         CALL SYMEXP(IRREP2,VRT(1,ISPIN),DISSYQ,ICORE(I000))
         CALL SYMEXP(IRREP2,VRT(1,ISPIN),DISSYQ,ICORE(I010))
C
C DO CONTRACTIONS 
C                           
C      I(ai) <= X1(mn,ea)*Q1(mn,ei) + X2(mn,ea)*Q2(mn,ei)
C
         IOFFQ1=I0Q1
         IOFFQ2=I0Q2
         IOFF1 =IFIRST
         IOFF2 =ISECOND
         IOFFI=I0I(ISPIN) 
         DO 110 IRREPI=1,NIRREP
          IRREPA=IRREPI
          IRREPE=DIRPRD(IRREPA,IRREP2)
          NUMA=VRT(IRREPA,ISPIN)
          NUMI=POP(IRREPI,ISPIN)
          NUME=VRT(IRREPE,ISPIN)
          NROW=NUMA
          NCOL=NUMI
          NSUM=NUMDSR*NUME
          CALL XGEMM('T','N',NROW,NCOL,NSUM,-HALF,ICORE(IOFF1),NSUM,
     &               ICORE(IOFFQ1),NSUM,ONE,ICORE(IOFFI),NROW)
          CALL XGEMM('T','N',NROW,NCOL,NSUM,-HALF,ICORE(IOFF2),NSUM,
     &               ICORE(IOFFQ2),NSUM,ONE,ICORE(IOFFI),NROW)
          IOFF1=IOFF1+NROW*NSUM*IINTFP
          IOFF2=IOFF2+NROW*NSUM*IINTFP
          IOFFQ1=IOFFQ1+NCOL*NSUM*IINTFP
          IOFFQ2=IOFFQ2+NCOL*NSUM*IINTFP
          IOFFI=IOFFI+NROW*NCOL*IINTFP
110      CONTINUE
C
        ELSE
C
C DO CONTRACTION 
C                           
C      I(AI) <= X1(Mn,Ae)*Q1(Mn,Ie) + X2(Mn,Ae)*Q2(Mn,Ie) [ISPIN=3]
C      I(ai) <= X1(Mn,Ea)*Q1(Mn,Ei) + X2(Mn,Ea)*Q2(Mn,Ei) [ISPIN=4]
C
         IF(ISPIN.EQ.3)THEN
          CALL SYMTR1(IRREP2,POP(1,1),VRT(1,2),DISSYQ,ICORE(I0Q1),
     &                ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
          CALL SYMTR1(IRREP2,POP(1,1),VRT(1,2),DISSYQ,ICORE(I0Q2),
     &                ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
          CALL SYMTR1(IRREP2,VRT(1,1),VRT(1,2),DISSYQ,ICORE(I000),
     &                ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
          CALL SYMTR1(IRREP2,VRT(1,1),VRT(1,2),DISSYQ,ICORE(I010),
     &                ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
         ENDIF
         IOFFQ1=I0Q1
         IOFFQ2=I0Q2
         IOFF1 =IFIRST
         IOFF2 =ISECOND
         IOFFI =I0I(ISPIN-2)
         DO 210 IRREPI=1,NIRREP
          IRREPA=IRREPI
          IRREPE=DIRPRD(IRREPA,IRREP2)
          NUMA=VRT(IRREPA,ISPIN-2)
          NUMI=POP(IRREPI,ISPIN-2)
          NUME=VRT(IRREPE,5-ISPIN)
          NROW=NUMA
          NCOL=NUMI
          NSUM=DISSYQ*NUME
          CALL XGEMM('T','N',NROW,NCOL,NSUM,-HALF,ICORE(IOFF1),NSUM,
     &               ICORE(IOFFQ1),NSUM,ONE,ICORE(IOFFI),NROW)
          CALL XGEMM('T','N',NROW,NCOL,NSUM,-HALF,ICORE(IOFF2),NSUM,
     &               ICORE(IOFFQ2),NSUM,ONE,ICORE(IOFFI),NROW)
          IOFF1=IOFF1+NROW*NSUM*IINTFP
          IOFF2=IOFF2+NROW*NSUM*IINTFP
          IOFFQ1=IOFFQ1+NCOL*NSUM*IINTFP
          IOFFQ2=IOFFQ2+NCOL*NSUM*IINTFP
          IOFFI=IOFFI+NROW*NCOL*IINTFP
210      CONTINUE
C
        ENDIF
C
100    CONTINUE
C
10    CONTINUE
C
      DO 300 ISPIN=1,1+IUHF
       CALL PUTLST(ICORE(I0I(ISPIN)),1,1,1,ISPIN,93)
300   CONTINUE
C
      RETURN
      END
