      SUBROUTINE MAKESS(ICORE,MAXCOR,IUHF)
C
C THIS ROUTINE FORMS THE SINGLE-SINGLE BLOCK OF EITHER THE REGULAR
C OR THE CCSD EFFECTIVE HAMILTONIAN
C
C       H(ai,bj) = F(ab) d(ij) - F(ij) d(ab) - W(ai,bj)
C
C WHERE F AND W ARE THE ONE AND TWO PARTICLE PARTS OF EXP(-T) H EXP(T).
C
CEND
      IMPLICIT INTEGER (A-Z)
      LOGICAL CIS,EOMCC,CISD,FULDIAG,INCORE,READGUES,RPA
      DOUBLE PRECISION ONE,ONEM,TWO
      DIMENSION ICORE(MAXCOR),IOFFO(2),IOFFV(2)
C
      COMMON/FLAGS/IFLAGS(100)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREP0(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/RESTART_COM/IRES
      COMMON/METH/CIS,RPA,EOMCC,CISD,FULDIAG,INCORE,READGUES
      COMMON/INFO/NOCCO(2),NVRTO(2)
C 
      DATA ONE,ONEM /1.0D0,-1.0D0/
      DATA TWO /2.0D0/
C
      CIS=.TRUE.
      IF(CIS)THEN
       LISTAA=23
       LIST3=42
      ELSE
       LIST3=56
      ENDIF
C
C ALLOCATE MEMORY FOR ONE-PARTICLE TERMS AND READ THEM IN
C
      I000=1
      I010=I000+NFMI(1)*IINTFP
      IF(IUHF.NE.0)THEN
       I020=I010+NFMI(2)*IINTFP
      ELSE
       I020=I010
      ENDIF
      I030=I020+NFEA(1)*IINTFP
      IF(IUHF.NE.0)THEN
       I040=I030+NFEA(2)*IINTFP
      ELSE
       I040=I030
      ENDIF
      IF(.NOT.CIS)THEN
       CALL IZERO(ICORE(I000),I040-1)
      ELSE
       IF (IFLAGS(38) .EQ. 1) THEN
C         write(6,*) ' non-hf contributions are added in makess'
C
C   NON HARTREE FOCK ORBITALS ARE USED -> ADD IN OFF-DIAGONAL PARTS F
C         
         PRINT*, 'INSIDE FXN: NON-HF CONTRIBUTION'
         CALL GETLST(ICORE(I000),1, 1, 1, 3, 91)
         CALL GETLST(ICORE(I020),1, 1, 1, 3, 92)
         print*, 'i000&i020',I000,I020
         call output(ICORE(I000),1,3,1,3,3,3,1)
         call output(ICORE(I002),1,3,1,3,3,3,1)
         IF (IUHF .EQ. 1) THEN
           print*, 'inside UHF call'
           CALL GETLST(ICORE(I010),1, 1, 1, 4, 91)
           CALL GETLST(ICORE(I030),1, 1, 1, 4, 92)
         call output(ICORE(I010),1,3,1,3,3,3,1)
         call output(ICORE(I030),1,3,1,3,3,3,1)
         ENDIF
       ELSE
         CALL IZERO(ICORE(I000),I040-1)
       ENDIF
       NBAS=NOCCO(1)+NVRTO(1)
       CALL GETREC(20,'JOBARC','SCFEVALA',IINTFP*NBAS,ICORE(I040))
       IOFFE=I040
       IOFFTO=I000
       IOFFTV=I020
       DO 10 IRREP=1,NIRREP
        NOCC=POP(IRREP,1)
        CALL SAXPY(NOCC,ONE,ICORE(IOFFE),1,ICORE(IOFFTO),NOCC+1)
        IOFFE=IOFFE+NOCC*IINTFP
        IOFFTO=IOFFTO+NOCC*NOCC*IINTFP
10     CONTINUE
        print*,'added eigenvalues'
         call output(ICORE(IOFFTO),1,3,1,3,3,3,1)
       DO 11 IRREP=1,NIRREP
        NVRT=VRT(IRREP,1)
        CALL SAXPY(NVRT,ONE,ICORE(IOFFE),1,ICORE(IOFFTV),NVRT+1)
        IOFFE=IOFFE+NVRT*IINTFP
        IOFFTV=IOFFTV+NVRT*NVRT*IINTFP
11     CONTINUE
C
       IF(IUHF.EQ.1)THEN
        CALL GETREC(20,'JOBARC','SCFEVALB',IINTFP*NBAS,ICORE(I040))
        IOFFE=I040
        IOFFTO=I010
        IOFFTV=I030
        DO 12 IRREP=1,NIRREP
         NOCC=POP(IRREP,2)
         CALL SAXPY(NOCC,ONE,ICORE(IOFFE),1,ICORE(IOFFTO),NOCC+1)
         IOFFE=IOFFE+NOCC*IINTFP
         IOFFTO=IOFFTO+NOCC*NOCC*IINTFP
12      CONTINUE
        DO 13 IRREP=1,NIRREP
         NVRT=VRT(IRREP,2)
         CALL SAXPY(NVRT,ONE,ICORE(IOFFE),1,ICORE(IOFFTV),NVRT+1)
         IOFFE=IOFFE+NVRT*IINTFP
         IOFFTV=IOFFTV+NVRT*NVRT*IINTFP
13      CONTINUE
       ENDIF        
      ENDIF
C
      IOFFO(1)=I000
      IOFFO(2)=I010
      IOFFV(1)=I020
      IOFFV(2)=I030
C
C READ IN ALL OF THE TWO-PARTICLE CONTRIBUTIONS, RESORT THEM AND
C HOLD IN CORE
C
      DO 100 ISPIN=1,1+IUHF
        PRINT*, 'ISPIN:', ISPIN,IUHF
       IF(CIS)THEN
        LISTAA=22+ISPIN
        print*, 'works'
        ISIZE=ISYMSZ(ISYTYP(1,LISTAA),ISYTYP(1,LISTAA))
        print*, 'does not'
        I050=I040+ISIZE*IINTFP
        I060=I050+ISIZE*IINTFP
        CALL GETALL(ICORE(I040),ISIZE,1,LISTAA)
        CALL VMINUS(ICORE(I040),ISIZE)
        IF(IUHF.EQ.0)THEN
         CALL GETALL(ICORE(I050),ISIZE,1,18)
         CALL SAXPY (ISIZE,ONE,ICORE(I050),1,ICORE(I040),1)
        ENDIF
       ELSEIF(.NOT.CIS)THEN
        print*,'not CIS'
        IF(IUHF.EQ.0)THEN
         ISIZE=ISYMSZ(ISYTYP(1,56),ISYTYP(1,56))
         I050=I040+ISIZE*IINTFP
         I060=I050+ISIZE*IINTFP
         CALL GETALL(ICORE(I040),ISIZE,1,56)
         CALL GETALL(ICORE(I050),ISIZE,1,58)
         CALL SSCAL(ISIZE,TWO,ICORE(I040),1)
         CALL SAXPY(ISIZE,ONEM,ICORE(I050),1,ICORE(I040),1)
        ELSE
         LISTAA=53+ISPIN
         ISIZE=ISYMSZ(ISYTYP(1,LISTAA),ISYTYP(1,LISTAA))
         I050=I040+ISIZE*IINTFP
         I060=I050+ISIZE*IINTFP
         CALL GETALL(ICORE(I040),ISIZE,1,LISTAA)
         CALL VMINUS(ICORE(I040),ISIZE)
        ENDIF
       ENDIF
C
       CALL SSTGEN(ICORE(I040),ICORE(I050),ISIZE,
     &             VRT(1,ISPIN),POP(1,ISPIN),VRT(1,ISPIN),
     &             POP(1,ISPIN),ICORE(I060),1,'1324')
C
C NOW ADD IN THE ONE-PARTICLE PART.  HERE WE ARE WORKING WITH THE
C ORDERING H(Ab,Ij) RATHER THAN H(AI,bj), SINCE THIS PERMITS US TO 
C USE ONLY THE FIRST IRREP
C
       DISSZ1=IRPDPD(1,18+ISPIN)
       NUMDS1=IRPDPD(1,20+ISPIN)
       CALL ADDONEH(ICORE(I050),ICORE(I040),ISIZE,ICORE(IOFFV(ISPIN)),
     &              ICORE(IOFFO(ISPIN)),DISSZ1,NUMDS1,ISPIN)
C
C NOW RESORT BACK TO AI,bj AND DUMP TO DISK ON APPROPRIATE LIST
C
       CALL SSTGEN(ICORE(I050),ICORE(I040),ISIZE,
     &             VRT(1,ISPIN),VRT(1,ISPIN),POP(1,ISPIN),
     &             POP(1,ISPIN),ICORE(I060),1,'1324')
C
       LISTDUMP=LIST3
       IF(IUHF.NE.0)LISTDUMP=LISTAA
cmn       IF(iuhf.eq.0.and.(IRES.NE.1.OR.CIS).or.
cmn     &    (cis.and.iflags(87).eq.1).or.
cmn     &    (cis.and.iflags(87).eq.6))THEN
        print*, 'Dumped to ', LISTDUMP
        CALL PUTALL(ICORE(I040),ISIZE,1,LISTDUMP)
cmn       ENDIF
C
100   CONTINUE
C
      RETURN
      END
