










      SUBROUTINE C1RPAHBAR1C1(ICORE,MAXCOR,IUHF,IRREPX,LISTT1,ISIDE,
     &                        IMULT)
C
C SOLVES FOR THE F*T1-> T1 CONTRACTION FOR GENERAL SYMMETRY
C T2 VECTORS.
C
C Z(A,I) = T(E,I) * F(EA) - T(A,M) * F(MI)  [ISPIN=1]
C
C Z(a,i) = T(e,i) * F(ea) - T(a,m) * F(ea)  [ISPIN=2]
C
C
CEND
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION ONE,ONEM,ZILCH
C
      DIMENSION ICORE(MAXCOR),IOFFEA(8),IOFFMI(8)
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON /SYM/ POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
C
      DATA ONE  /1.0/
      DATA ONEM /-1.0/
      DATA ZILCH/0.0/

      IF (ISIDE .EQ. 2) THEN
           WRITE(6,"(a,i2)") "The value for ISIDE ",ISIDE, " is invalid"
           CALL ERREX
      ENDIF

      DO 10 ISPIN=1,1+IUHF
       LENT1=IRPDPD(IRREPX,8+ISPIN)
       I000=1
       I010=I000+IINTFP*LENT1
       I020=I010+IINTFP*LENT1
       I030=I020+IINTFP*NFMI(ISPIN)
       I040=I030+IINTFP*NFEA(ISPIN)
C
       CALL GETLST(ICORE(I010),1,1,1,ISPIN,LISTT1)
       IF (IMULT .EQ. 1) THEN
          CALL GETLST(ICORE(I020),1,1,1,ISPIN,91)
          CALL GETLST(ICORE(I030),1,1,1,ISPIN,92)
       ELSE IF (IMULT .EQ. 2) THEN
          CALL GETLST(ICORE(I020),1,1,1,10,91)
          CALL GETLST(ICORE(I030),1,1,1,10,92)
       ENDIF 
      
       call checksum("@-c1rpa_Fmi1:",ICORE(I020),NFMI(ISPIN),s)
       call checksum("@-c1rpa_Fae1:",ICORE(I030),NFEA(ISPIN),s)
C
       IOFFZ=I000
       IOFFT=I010
       IOFFFMI0=I020
       IOFFFEA0=I030
C
       IOFFEA(1)=0
       IOFFMI(1)=0
       DO 13 IRREPR=1,NIRREP-1
        IOFFEA(IRREPR+1)=IOFFEA(IRREPR)+
     &                 VRT(IRREPR,ISPIN)*VRT(IRREPR,ISPIN)
        IOFFMI(IRREPR+1)=IOFFMI(IRREPR)+
     &                 POP(IRREPR,ISPIN)*POP(IRREPR,ISPIN)
13     CONTINUE
C
       DO 15 IRREPI=1,NIRREP
        IRREPA=DIRPRD(IRREPI,IRREPX)
        NUMA=VRT(IRREPA,ISPIN)
        NUMI=POP(IRREPI,ISPIN)
C               +
C Z(A,I) = F(EA) * T(EI)  [RIGHT EIGENPROBLEM]
C               
C Z(A,I) = F(AE) * T(EI)  [LEFT EIGENPROBLEM]
C
        IRREPE=IRREPA
        NUME=VRT(IRREPE,ISPIN)
        IOFFFEA=IOFFFEA0+IOFFEA(IRREPA)*IINTFP
        IF(ISIDE.EQ.1)THEN
         CALL XGEMM('T','N',NUMA,NUMI,NUME,ONE,ICORE(IOFFFEA),NUME,
     &              ICORE(IOFFT),NUME,ZILCH,ICORE(IOFFZ),NUMA)
        ELSE
         CALL XGEMM('N','N',NUMA,NUMI,NUME,ONE,ICORE(IOFFFEA),NUMA,
     &              ICORE(IOFFT),NUME,ZILCH,ICORE(IOFFZ),NUMA)
        ENDIF
C               
C Z(A,I) = Z(A,I) - T(A,M) * F(MI) [RIGHT EIGENPROBLEM]
C
C                                 + 
C Z(A,I) = Z(A,I) - T(A,M) * F(IM) [LEFT EIGENPROBLEM]
C
        IRREPM=IRREPI
        NUMM=POP(IRREPM,ISPIN)
        IOFFFMI=IOFFFMI0+IOFFMI(IRREPI)*IINTFP 
        IF(ISIDE.EQ.1)THEN
         CALL XGEMM('N','N',NUMA,NUMI,NUMM,ONEM,ICORE(IOFFT),NUMA,
     &              ICORE(IOFFFMI),NUMM,ONE,ICORE(IOFFZ),NUMA)
        ELSE
         CALL XGEMM('N','T',NUMA,NUMI,NUMM,ONEM,ICORE(IOFFT),NUMA,
     &              ICORE(IOFFFMI),NUMI,ONE,ICORE(IOFFZ),NUMA)
        ENDIF
        IOFFT=IOFFT+NUME*NUMI*IINTFP
        IOFFZ=IOFFZ+NUMA*NUMI*IINTFP
15     CONTINUE
C
       CALL GETLST(ICORE(I010),1,1,1,ISPIN+2,LISTT1)
       CALL SAXPY (LENT1,ONE,ICORE(I000),1,ICORE(I010),1)
       CALL PUTLST(ICORE(I010),1,1,1,ISPIN+2,LISTT1)
C
10    CONTINUE
C
      RETURN
      END
