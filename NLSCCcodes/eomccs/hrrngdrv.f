      SUBROUTINE HRRNGDRV(ICORE,MAXCOR,LISTW,LISTR,CALMOD,MAXSIZ,
     &                    INCREM,LSTSCR,TAU,T1A,T1B,R1A,R1B,
     &                    POP1,POP2,VRT1, 
     &                    VRT2,FACT,SPCASE,IUHF)
C     
C     THIS SUBROUTINE IS CALLED BY H4T2ALL
C     
CEND  
C
      IMPLICIT INTEGER (A-Z)
      LOGICAL TAU
      CHARACTER*3 CALMOD
      CHARACTER*4 SPCASE
      DOUBLE PRECISION FACT,T1A(1),T1B(1),R1A(1),R1B(1)
      DOUBLE PRECISION AZERO,ONE,ONEM,HALF
      DIMENSION ICORE(MAXCOR),VRT1(8),VRT2(8),POP1(8),POP2(8)
      COMMON /STATSYM/IRREPX
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(2,255),DIRPRD(8,8)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
C
      DATA AZERO,ONE,ONEM,HALF /0.D0,1.0D0,-1.D0,0.5D0/
C
C LOOP OVER IRREPS.
C
       DO 100 IRREPR=1,NIRREP
        IRREPL=DIRPRD(IRREPX,IRREPR)
        LISTR2=LISTR
        IF(IUHF.EQ.0.AND.LISTR.EQ.454) LISTR2=459
        DISSYW=IRPDPD(IRREPL,ISYTYP(1,LISTW))
        DISSYT=IRPDPD(IRREPR,ISYTYP(1,LISTR2))
        NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
        NUMSYT=IRPDPD(IRREPL,ISYTYP(2,LISTR2))
        DISSYQ=DISSYT
        NUMSYQ=NUMSYW
        MAXSIZ=MAX(NUMSYQ*DISSYQ,MAXSIZ)
        I000=1
        I010=I000+IINTFP*NUMSYQ*DISSYQ
        I020=I010+IINTFP*NUMSYT*DISSYT
        I030=I020+IINTFP*DISSYW*NUMSYW
C
C CAN WE DO IT IN CORE?
C
        IF(I030.LT.MAXCOR)THEN
C
C FORM THE SYMMETRY PACKED Q VECTOR.
C
         IF(IUHF.EQ.0.AND.LISTR.EQ.454) THEN
          CALL GETLST(ICORE(I010),1,NUMSYT,1,IRREPL,459)
          CALL GETLST(ICORE(I020),1,NUMSYT,1,IRREPL,457)
          CALL SAXPY(NUMSYT*DISSYT,ONEM,ICORE(I020),1,ICORE(I010),1)
         ELSE  
          CALL GETLST(ICORE(I010),1,NUMSYT,1,IRREPL,LISTR)
         ENDIF
         IF(TAU) THEN
          CALL G2TAU(ICORE(I010),T1A,T1B,R1A,R1B,
     &               DISSYT,NUMSYT,POP1,POP2,
     &               VRT1,VRT2,IRREPL,IRREPX,FACT,SPCASE)
         ENDIF
         CALL GETLST(ICORE(I020),1,NUMSYW,2,IRREPR,LISTW)
C
C  SCALE H4 FIRST BY 0.5
C
         CALL SSCAL(NUMSYW*DISSYW,HALF,ICORE(I020),1)
C
         IF(MIN(DISSYT,NUMSYT,NUMSYW).NE.0)THEN
          CALL XGEMM('N','N',DISSYT,NUMSYW,NUMSYT,ONE,
     &                ICORE(I010),DISSYT,ICORE(I020),NUMSYT,AZERO,
     &                ICORE(I000),DISSYT) 
c          CALL MXM(ICORE(I010),DISSYT,ICORE(I020),NUMSYT,ICORE(I000),
c     &             NUMSYW)
          ELSE
           CALL ZERO(ICORE(I000),DISSYT*NUMSYW)
         ENDIF
        ELSE
         CALL INSMEM('HRRNGDRV',I030,MAXCOR)
        ENDIF
        IF(CALMOD.EQ.'WxT')THEN
         CALL TRANSP(ICORE(I000),ICORE(I010),NUMSYQ,DISSYQ)
c YAU : old
c        CALL ICOPY(IINTFP*NUMSYQ*DISSYQ,ICORE(I010),1,ICORE(I000),1)
c YAU : new
         CALL DCOPY(NUMSYQ*DISSYQ,ICORE(I010),1,ICORE(I000),1)
c YAU : end
         ITMP=NUMSYQ
         NUMSYQ=DISSYQ
         DISSYQ=ITMP
        ENDIF
C
C AUGMENT Q(ABAB) AND DUMP IT TO DISK.
C
        IF(INCREM.EQ.1)THEN
         CALL GETLST(ICORE(I020),1,NUMSYQ,1,IRREPR,LSTSCR)
         CALL VADD(ICORE(I020),ICORE(I020),ICORE(I000),
     &             DISSYQ*NUMSYQ,1.D0)
         CALL PUTLST(ICORE(I020),1,NUMSYQ,1,IRREPR,LSTSCR)
c YAU : old
c        CALL ICOPY(IINTFP*DISSYQ*NUMSYQ,ICORE(I020),1,ICORE(I000),1)
c YAU : new
         CALL DCOPY(DISSYQ*NUMSYQ,ICORE(I020),1,ICORE(I000),1)
c YAU : end
        ELSE
         CALL PUTLST(ICORE(I000),1,NUMSYQ,1,IRREPR,LSTSCR)
        ENDIF
100    CONTINUE
       RETURN
       END
