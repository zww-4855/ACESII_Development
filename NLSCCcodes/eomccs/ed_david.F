      SUBROUTINE ED_DAVID(IUHF, IRREPX, ISIDE, NROOT, MAXPOWER, MAXEXP,
     &   N1AA, NDIM, ZOUT, ZLEFT, EOUT, EOLD, Z, HZ, E0, H0, ICONV,
     &   SCR, MAXCOR, ITYPECONV, TOL, DOLEFT, LOCKLEFT)
C
C  THE ENERGY DEPENDENT EIGENVALUE PROBLEM H(E) = (A + B (E-D)^-1 C) Z = E Z
C  IS SOLVED FOR NROOTS SIMULTANEOUSLY, USING A VERSION OF THE DAVIDSON
C  METHOD. THE DIMENSION OF A (Z) IS NDIM, THE NUMBER OF SINGLE EXCITATIONS
C   (WITH N1AA ALPHA COMPONENTS).
C  
C  THE DAVIDSON PROCEDURE IS MODIFIED IN THAT WE ESTIMATE THE ENERGY
C  DEPENDENCE OF H(E)Z THROUGH A POWER SERIES IN THE DENOMINATOR (E-D)^-1
C  IN EACH DAVIDSON MULTIPLICATION STEP WE CALCULATE
C   (HZ(E0, IPOWER) = B (E0 - D)^-IPOWER C Z, FOR IPOWER IS 1..MAXPOWER
C   THIS ALLOWS US TO CONSTRUCT H(E)Z APPROXIMATELY AS 
C   H(E) Z = A Z + SUM{IPOWER} (E0 - E)**(IPOWER -1) * HZ(E0, IPOWER)
C
C   THE SUBMATRIX Z . H(E) Z CAN BE DIAGONALIZED AS USUAL IN THE DAVIDSON PROCEDURE
C
C  INPUT : NROOT INITIAL ESTIMATES ZOUT AND EOUT
C          MAXPOWER: THE DEGREE OF THE POWER EXPANSION
C          N1AA, NDIM : THE DIMENSION OF Z
C          MAXEXP: THE MAXIMUM NUMBER OF EXPANSION VECTORS
C          ITYPECONV: THE TYPE OF CONVERGENCE
C                = 1  : THE EIGENVALUES ARE CONVERGED (CRUDE ESTIMATE)
C                = 2  : THE EIGENVECTORS ARE MONITORED
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      LOGICAL PRINT, DOLEFT, LOCKLEFT
C
      DIMENSION SCR(MAXCOR), Z(NDIM, MAXEXP), E0(MAXEXP),
     &   HZ(NDIM, MAXEXP, MAXPOWER), ZOUT(NDIM, NROOT), EOUT(NROOT),
     &   H0(NDIM), ICONV(NROOT), EOLD(NROOT), ZLEFT(NDIM, NROOT)
C
      COMMON/PROJECT/IPROJECT, IPATTERN, NCALC, ICALC, IWINDOW(8)
      COMMON/LISTPROJ/LISTH0, ICOLPR1, ICOLPR2
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /FLAGS/ IFLAGS(100)
C
      PRINT = IFLAGS(1) .GT. 0
      FACTSQ2 = SQRT(2.0D0)
      FACTEV = 27.2113957D0
      LISTPRJ = 498
      TOLZ=TOL
      TOLE=TOLZ /100.0D0
      TOLE2 = TOL
C
C  DETERMINE H0 IN SPACE OF SINGLE EXCITATIONS
C
      CALL GETLST(SCR,1,1,1,1,472)
      CALL SCOPY(NDIM, SCR, 1, H0, 1)
C
C  INITIALIZE CONVERGENCE PER ROOT
C
      DO I = 1, NROOT
        ICONV(I) = 1
      ENDDO
C
C  THE VECTORS ARE PROCESSED IN BLOCKS OF NROOT 
C
      CALL SCOPY(NROOT*NDIM, ZOUT, 1, Z, 1)
      CALL SCOPY(NROOT, EOUT, 1, E0, 1)
C
C
C  ORTHOGONALIZE CURRENT EXPANSION SPACE 
C
      DO I = 1, NROOT
        CALL GSCHMIDT(Z(1,I), Z, NDIM, I-1, SCR, RESID)
      ENDDO
C
      NSPACE = NROOT
      NSTART = 1
C
  100 CONTINUE
C
C  CALCULATE HZ(E0), FOR I = NSTART, NSPACE
C
C      IF (IUHF .EQ. 0) THEN
C        DO I = 1, NSPACE
C          CALL SSCAL(NDIM, 1.D0/FACTSQ2,Z(1,I),1)
C        ENDDO
C      ENDIF
C
      DO 10 I = NSTART, NSPACE
C
#ifdef _DEBUG_LVLM
      Write(6,"(a,4(i4))") "The variables LISTH0, ICOLPR1, ICOLPR2",
     &                      LISTH0, ICOLPR1, ICOLPR2

      Write(6,"(a,4(i4))") "The variables IPROJECT, IPATTERN, NCALC,
     &                      ICALC",
     &                      IPROJECT, IPATTERN, NCALC, ICALC
#endif 
      IF (IPROJECT .GE. 2) THEN
         I000 = 1
         I010 = I000 + NDIM
         CALL GETLST(SCR(I010),1,NROOT,1,IRREPX,LISTH0)
         CALL VECPRD(Z(1,I),SCR(I010),Z(1,I),NDIM)

#ifdef _DEBUG_LVLM
      Write(6,"(a)")" The checksum of the PR1"
      Call checksum(" @-EDDAVDAV",Z(1,I),NDIM,S1)
#endif 
      ENDIF
C
C PUT VECTOR ON LIST
C
        CALL PUTLST(Z(1,I), 1, 1, 1, 1, 490)
        IF (IUHF .NE. 0) CALL PUTLST(Z(N1AA+1,I),1,1,1,2,490)
C
C CALCULATE H(E0) * Z AND ITS POWERS
C
C   FIRST IPOWER = 1
C
        CALL PHBARXC(SCR, MAXCOR*IINTFP,IUHF, ISIDE, IRREPX,
     &     .TRUE., .TRUE., .TRUE., .FALSE., E0(I), 1)
C
        CALL GETLST(HZ(1,I,1), 1, 1, 1, 3, 490)
        IF (IUHF .NE. 0) CALL GETLST(HZ(N1AA+1,I,1),1,1,1,4,490)
C
        DO IPOWER = 2, MAXPOWER
C
          CALL PHBARXC(SCR, MAXCOR*IINTFP,IUHF, ISIDE, IRREPX,
     &       .FALSE., .FALSE., .TRUE., .FALSE., E0(I), IPOWER)
C
          CALL GETLST(HZ(1,I,IPOWER), 1, 1, 1, 3, 490)
          IF (IUHF .NE. 0) CALL GETLST(HZ(N1AA+1,I,IPOWER),1,1,1,4,490)
C
        ENDDO
C
   10 CONTINUE
C
C  FIND NEW EIGENVALUES AND EIGENVECTORS BY DIAGONALIZING ASMALL(E)
C  SELF-CONSISTENTLY
C
      IASMALL = 1
      IAPOWER = IASMALL + NSPACE * NSPACE
      IZTMP = IAPOWER + NSPACE*NSPACE*MAXPOWER
      ISCR = IZTMP + NDIM
C
      CALL SCOPY(NROOT, EOUT, 1, EOLD, 1)
C
      CALL ED_DIAG(ZOUT, NDIM, EOUT, NROOT, Z, HZ, MAXEXP, E0,
     &   SCR(IASMALL), SCR(IAPOWER), NSPACE,MAXPOWER, ICONV,
     &   SCR(IZTMP), SCR(ISCR), MAXCOR-ISCR+1, TOLE, IUHF)
C
      IF (ISIDE .EQ. 2 .AND. LOCKLEFT) CALL SCOPY(NROOT, EOLD, 1,
     &   EOUT, 1)
C
C  CHECK IF ENERGIES OF FIRST ITERATION IS SO FAR OFF THAT THEY SHOULD
C  BE REDONE
C
      IF (ISIDE .EQ. 1) THEN
        DO IROOT = 1, NROOT
          IF (ABS(EOLD(IROOT) - EOUT(IROOT)) .LT. 1.0D-3) THEN
            IF (ABS(EOUT(IROOT) - E0(IROOT)) .GT. 0.1) THEN
              write(6,*) ' Too big difference between E0 and E '
              write(6,*) ' Redo initial iteration for root ', IROOT
C
              I = IROOT
              E0(I) = EOUT(IROOT)
              CALL PUTLST(Z(1,I), 1, 1, 1, 1, 490)
              IF (IUHF .NE. 0) CALL PUTLST(Z(N1AA+1,I),1,1,1,2,490)
C
C CALCULATE H(E0) * Z AND ITS POWERS
C
C   FIRST IPOWER = 1
C
              CALL PHBARXC(SCR, MAXCOR*IINTFP,IUHF, ISIDE, IRREPX,
     &           .TRUE., .TRUE., .TRUE., .FALSE., E0(I), 1)
C
              CALL GETLST(HZ(1,I,1), 1, 1, 1, 3, 490)
              IF (IUHF .NE. 0) CALL GETLST(HZ(N1AA+1,I,1),1,1,1,4,490)
C
              DO IPOWER = 2, MAXPOWER
C
                CALL PHBARXC(SCR, MAXCOR*IINTFP,IUHF, ISIDE, IRREPX,
     &             .FALSE., .FALSE., .TRUE., .FALSE., E0(I), IPOWER)
C
                CALL GETLST(HZ(1,I,IPOWER), 1, 1, 1, 3, 490)
                IF (IUHF .NE. 0) CALL GETLST(HZ(N1AA+1,I,IPOWER),
     &             1,1,1,4,490)
C
              ENDDO
            ENDIF
          ENDIF
        ENDDO
      ENDIF
C
      NSTART = NSPACE + 1
C
C CONSTRUCT NEW EXPANSION VECTORS
C
C  Z(I) = 1/(E-A0(I)) * [A(E) * Z - E*Z) ]
C
      DO 20 IROOT = 1, NROOT
        IF (ICONV(IROOT) .NE. 0) THEN
C
C  CALCULATE A(E) * ZOUT(IROOT)
C
          CALL ZERO(SCR, NDIM)
          ROOT = EOUT(IROOT)           
          DO I = 1, NSPACE
            FACTI = SDOT(NDIM,Z(1,I),1,ZOUT(1,IROOT),1)
              DO IPOWER = 1, MAXPOWER
                FACTEI = (E0(I) - ROOT)**(IPOWER-1) * FACTI
                CALL SAXPY(NDIM,FACTEI,HZ(1,I,IPOWER),1,SCR,1)
              ENDDO
          ENDDO
C
C CALCULATE RESIDUAL [A(E)-E] Z AND APPLY DAVIDSON CORRECTION 
C
          CALL SAXPY(NDIM,-ROOT,ZOUT(1,IROOT),1,SCR,1)
C
C DETERMINE MAXIMUM ERROR
C
          IF (ITYPECONV .EQ. 1) THEN
            DIFF = ABS(EOUT(IROOT) - EOLD(IROOT))
            IF (DIFF .LT. TOLE2) ICONV(IROOT) = 0
          ELSE
            CALL FNDMAXD(NDIM, SCR, DIFF, ILOC)
            IF (DIFF .LT. TOLZ) ICONV(IROOT) = 0
          ENDIF
C
          IF(PRINT)WRITE(6,1002)IROOT, NSTART-1,ROOT,ROOT*FACTEV,DIFF
C
          IF (ICONV(IROOT) .NE. 0 .AND. NSPACE .LT. MAXEXP) THEN
C
C CALCULATE RESIDUAL
C
            DO I=1,NDIM
              X=ROOT - H0(I)
              if (abs(x) .lt. 1.d-4) then
                write(6,*) ' singular denominator', x
                x = 1.0d-4
              endif
              SCR(I) = SCR(I) / X
            ENDDO
C
C Project the residuals.
C
      IF (IPROJECT .GE. 2) THEN
         I000 = 1
         I010 = I000 + NDIM
         CALL GETLST(SCR(I010),1,NROOT,1,IRREPX,LISTPRJ)
         CALL VECPRD(SCR,SCR(I010),SCR,NDIM)
      ENDIF
C
C ORTHOGONALIZE RESIDUAL TO EXISTING SPACE
C
            CALL GSCHMIDT(SCR,Z,NDIM, NSPACE,
     &         SCR(NDIM+1),RESID)
C
C INCREASE NSPACE
C
            NSPACE = NSPACE + 1
            CALL SCOPY(NDIM, SCR, 1, Z(1,NSPACE),1)
            E0(NSPACE) = ROOT
          ENDIF
      
          IF (PRINT) CALL PRMAINX(IUHF, SCR, MAXCOR, IRREPX,IROOT)
C       
C PROCESS NEXT ROOT
C
        ENDIF
   20 CONTINUE
C
C DETERMINE THE NUMBER OF UNDETERMINED ROOTS AND SEE IF WE
C CAN MAKE ANOTHER PASS
C
      IROOT = NSPACE - NSTART + 1
      IF (IROOT .GT. 0) GO TO 100
C
C CALCULATE ESTIMATES FOR LEFT HAND SIDE
C
      IF (DOLEFT) THEN
        DO I = 1, NROOT
          ICONV(I) = 1
        ENDDO
        CALL SCOPY(NROOT*NDIM, ZOUT, 1, ZLEFT, 1)
        CALL SCOPY(NROOT,EOUT, 1, EOLD, 1)
C
        IASMALL = 1
        IAPOWER = IASMALL + NSPACE * NSPACE
        IZTMP = IAPOWER + NSPACE*NSPACE*MAXPOWER
        ISCR = IZTMP + NDIM
        CALL INITLEFT(ZLEFT, NDIM, EOLD, NROOT, Z, HZ, MAXEXP, E0,
     &     SCR(IASMALL), SCR(IAPOWER), NSPACE,MAXPOWER, ICONV,
     &     SCR(IZTMP), SCR(ISCR), MAXCOR-ISCR+1, TOLE, IUHF)
      ENDIF
C
      RETURN
 1002 FORMAT(T7,I4,T18,I4,F15.8,F17.8,5X,E8.3)
      END


