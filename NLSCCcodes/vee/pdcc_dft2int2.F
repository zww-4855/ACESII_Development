      SUBROUTINE PDCC_DFT2INT2(ICORE,MAXCOR,IUHF,IRREPX,LISTT0,
     &                        LISTZ0,ISIDE)
C
C SOLVES FOR THE F*T2-> T2 CONTRACTION FOR GENERAL SYMMETRY
C T2 VECTORS AND RHF REFERENCE FUNCTIONS.
C
CEND
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION ONE,ONEM,ZILCH,HALF
C
      DIMENSION ICORE(MAXCOR)
      LOGICAL MBPT2,CC,CCD,RCCD,DRCCD,LCCD,LCCSD,CC2,ADC2
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON /SYM/ POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /REFTYPE/ MBPT2,CC,CCD,RCCD,DRCCD,LCCD,LCCSD,CC2
      COMMON /FLAGS/ IFLAGS(100)
      COMMON /FLAGS2/ IFLAGS2(500)
C
      DATA ONE  /1.0/
      DATA HALF /0.5/
      DATA ONEM /-1.0/
      DATA ZILCH/0.0/
C
C FIRST DO THE ALPHA-BETA SPIN CASE
C
C ADC2 check; CALC=MBPT(2),EXCITE=EOMEE,EOMREF=ADC2
C
      ADC2 = .FALSE.
      ADC2 =  (IFLAGS(2) .EQ. 1 .AND. IFLAGS(87) .EQ. 3 .AND.
     &         IFLAGS2(117) .EQ. 10)
C
      IOFF = 8
C
      DO 100 IRREPZR=1,NIRREP
       IRREPZL=DIRPRD(IRREPZR,IRREPX)
       IRREPTR=IRREPZR
       IRREPTL=IRREPZL
       LISTT=LISTT0-1+4
       LISTZ=LISTZ0+2
       DISSYZ=IRPDPD(IRREPZL,ISYTYP(1,LISTZ))
       NUMDSZ=IRPDPD(IRREPZR,ISYTYP(2,LISTZ))
       DISSYT=DISSYZ
       NUMDST=NUMDSZ
       MAXT=MAX(DISSYT,NUMDST)
       I000=1
       I010=I000+IINTFP*NUMDSZ*DISSYZ
       I020=I010+IINTFP*NUMDST*DISSYT
       I030=I020+IINTFP*MAX(NFMI(2),NFMI(1))
       I040=I030+IINTFP*MAX(NFEA(2),NFEA(1))
       I050=I040+IINTFP*MAXT
       I060=I050+IINTFP*MAXT
       I070=I060+IINTFP*MAXT
       CALL GETLST(ICORE(I010),1,NUMDST,1,IRREPTR,LISTT)
       CALL GETLST(ICORE(I020),1,1,1,1+IUHF+IOFF,91)
       CALL GETLST(ICORE(I030),1,1,1,1+IUHF+IOFF,92)
       CALL ZERO  (ICORE(I000),DISSYZ*NUMDSZ)
C
C CARRY OUT  CONTRACTION :
C
C    -T(AI,bm) * F(mj) [RIGHT EIGENPROBLEM]
C
C                     +
C    -T(AI,bm) * F(jm) [LEFT EIGENPROBLEM]
C
       IOFFF=I020
       IOFFT=I010
       IOFFZ=I000
       DO 110 IRREPM=1,NIRREP
        IRREPJ=IRREPM
        IRREPB=DIRPRD(IRREPM,IRREPTR)
        NUMM=POP(IRREPM,2)
        NUMJ=POP(IRREPJ,2)
        NUMB=VRT(IRREPB,2)
        NROW=DISSYT*NUMB
        NCOL=NUMJ
        NSUM=NUMM
        IF(ISIDE.EQ.1)THEN
         CALL XGEMM('N','N',NROW,NCOL,NSUM,ONEM,ICORE(IOFFT),NROW,
     &              ICORE(IOFFF),NSUM,ZILCH,ICORE(IOFFZ),NROW)
        ELSE
         CALL XGEMM('N','T',NROW,NCOL,NSUM,ONEM,ICORE(IOFFT),NROW,
     &              ICORE(IOFFF),NCOL,ZILCH,ICORE(IOFFZ),NROW)
        ENDIF
        IOFFZ=IOFFZ+NROW*NCOL*IINTFP
        IOFFT=IOFFT+NROW*NSUM*IINTFP
        IOFFF=IOFFF+NUMM*NUMJ*IINTFP
110    CONTINUE
C
C NOW TRANSPOSE KET INDICES
C
       CALL SYMTR1(IRREPTR,VRT(1,2),POP(1,2),DISSYT,ICORE(I000),
     &             ICORE(I040),ICORE(I050),ICORE(I060))
       CALL SYMTR1(IRREPTR,VRT(1,2),POP(1,2),DISSYT,ICORE(I010),
     &             ICORE(I040),ICORE(I050),ICORE(I060))
C
C NOW CARRY OUT CONTRACTION :
C
C        T(AI,je) * F(eb) [RIGHT EIGENPROBLEM]
C
C                        +
C        T(AI,je) * F(be) [LEFT EIGENPROBLEM]
C
       IOFFF=I030
       IOFFT=I010
       IOFFZ=I000
       DO 120 IRREPE=1,NIRREP
        IRREPB=IRREPE
        IRREPJ=DIRPRD(IRREPE,IRREPTR)
        NUMJ=POP(IRREPJ,2)
        NUME=VRT(IRREPE,2)
        NUMB=VRT(IRREPB,2)
        NROW=DISSYT*NUMJ
        NCOL=NUMB
        NSUM=NUME
        IF(ISIDE.EQ.1)THEN
         CALL XGEMM('N','N',NROW,NCOL,NSUM,ONE,ICORE(IOFFT),NROW,
     &              ICORE(IOFFF),NSUM,ONE,ICORE(IOFFZ),NROW)
        ELSE
         CALL XGEMM('N','T',NROW,NCOL,NSUM,ONE,ICORE(IOFFT),NROW,
     &              ICORE(IOFFF),NCOL,ONE,ICORE(IOFFZ),NROW)
        ENDIF
        IOFFT=IOFFT+NROW*NSUM*IINTFP
        IOFFF=IOFFF+NUME*NUMB*IINTFP
        IOFFZ=IOFFZ+NROW*NCOL*IINTFP
120    CONTINUE
C
C FOR RHF, TRANSPOSE KET INDICES OF TARGET AND WRITE TO RING LISTS
C
       IF(IUHF.EQ.0)THEN
        CALL SYMTR1(IRREPTR,POP(1,2),VRT(1,2),DISSYT,ICORE(I000),
     &              ICORE(I040),ICORE(I050),ICORE(I060))
        CALL PUTLST(ICORE(I000),1,NUMDSZ,1,IRREPZR,LISTZ)
       ELSE
C
C DO TRANSPOSITIONS: 
C 
C      Z(AM,jb) -> Z(jb,AM) 
C      T(AM,je) -> T(je,AM)
C
        CALL TRANSP(ICORE(I010),ICORE(I020),NUMDST,DISSYT)
c YAU : old
c       CALL ICOPY(NUMDST*DISSYT*IINTFP,ICORE(I020),1,ICORE(I010),1)
c YAU : new
        CALL DCOPY(NUMDST*DISSYT,ICORE(I020),1,ICORE(I010),1)
c YAU : end
        CALL TRANSP(ICORE(I000),ICORE(I020),NUMDSZ,DISSYZ)
c YAU : old
c       CALL ICOPY(NUMDSZ*DISSYZ*IINTFP,ICORE(I020),1,ICORE(I000),1)
c YAU : new
        CALL DCOPY(NUMDSZ*DISSYZ,ICORE(I020),1,ICORE(I000),1)
c YAU : end
        CALL GETLST(ICORE(I020),1,1,1,1+IOFF,91)
        CALL GETLST(ICORE(I030),1,1,1,1+IOFF,92)
C
C CARRY OUT  CONTRACTION :
C
C    -T(jb,AM) * F(MI) [RIGHT EIGENPROBLEM]
C
C                     +
C    -T(jb,AM) * F(IM) [LEFT EIGENPROBLEM]
C
        IOFFF=I020
        IOFFT=I010
        IOFFZ=I000
        DO 210 IRREPM=1,NIRREP
         IRREPI=IRREPM
         IRREPA=DIRPRD(IRREPM,IRREPTL)
         NUMM=POP(IRREPM,1)
         NUMI=POP(IRREPI,1)
         NUMA=VRT(IRREPA,1)
         NROW=NUMDST*NUMA
         NCOL=NUMI
         NSUM=NUMM
         IF(ISIDE.EQ.1)THEN
          CALL XGEMM('N','N',NROW,NCOL,NSUM,ONEM,ICORE(IOFFT),NROW,
     &               ICORE(IOFFF),NSUM,ONE,ICORE(IOFFZ),NROW)
         ELSE
          CALL XGEMM('N','T',NROW,NCOL,NSUM,ONEM,ICORE(IOFFT),NROW,
     &               ICORE(IOFFF),NCOL,ONE,ICORE(IOFFZ),NROW)
         ENDIF
         IOFFZ=IOFFZ+NROW*NCOL*IINTFP
         IOFFT=IOFFT+NROW*NSUM*IINTFP
         IOFFF=IOFFF+NUMM*NUMI*IINTFP
210     CONTINUE
C
C NOW TRANSPOSE KET INDICES
C
C      Z(jb,EI) -> Z(jb,IE) 
C      T(jb,EI) -> T(je,IE)
C
        CALL SYMTR1(IRREPTL,VRT(1,1),POP(1,1),NUMDST,ICORE(I000),
     &              ICORE(I040),ICORE(I050),ICORE(I060))
        CALL SYMTR1(IRREPTL,VRT(1,1),POP(1,1),NUMDST,ICORE(I010),
     &              ICORE(I040),ICORE(I050),ICORE(I060))
C
C
C NOW CARRY OUT CONTRACTION :
C
C        T(jb,IE) * F(EA) [RIGHT EIGENPROBLEM]
C
C                        +
C        T(jb,IE) * F(AE) [LEFT EIGENPROBLEM]
C
        IOFFF=I030
        IOFFT=I010
        IOFFZ=I000
        DO 220 IRREPE=1,NIRREP
         IRREPA=IRREPE
         IRREPI=DIRPRD(IRREPE,IRREPTL)
         NUMI=POP(IRREPI,1)
         NUME=VRT(IRREPE,1)
         NUMA=VRT(IRREPA,1)
         NROW=NUMDST*NUMI
         NCOL=NUMA
         NSUM=NUME
         IF(ISIDE.EQ.1)THEN
          CALL XGEMM('N','N',NROW,NCOL,NSUM,ONE,ICORE(IOFFT),NROW,
     &               ICORE(IOFFF),NSUM,ONE,ICORE(IOFFZ),NROW)
         ELSE
          CALL XGEMM('N','T',NROW,NCOL,NSUM,ONE,ICORE(IOFFT),NROW,
     &               ICORE(IOFFF),NCOL,ONE,ICORE(IOFFZ),NROW)
         ENDIF
         IOFFT=IOFFT+NROW*NSUM*IINTFP
         IOFFF=IOFFF+NUME*NUMA*IINTFP
         IOFFZ=IOFFZ+NROW*NCOL*IINTFP
220     CONTINUE
C
C WE NOW HAVE WHAT WE WANT, BUT IN THE RATHER UNFORTUNATE ORDERING
C   Z(jb,IA).  LET US NOW REARRANGE THIS (TEDIOUSLY) TO Z(AI,bj)
C
        CALL SYMTR1(IRREPTL,POP(1,1),VRT(1,1),NUMDST,ICORE(I000),
     &              ICORE(I040),ICORE(I050),ICORE(I060))
        CALL TRANSP(ICORE(I000),ICORE(I010),DISSYT,NUMDST)
c YAU : old
c       CALL ICOPY(DISSYT*NUMDST*IINTFP,ICORE(I010),1,ICORE(I000),1)
c YAU : new
        CALL DCOPY(DISSYT*NUMDST,ICORE(I010),1,ICORE(I000),1)
c YAU : end
        CALL SYMTR1(IRREPTR,POP(1,2),VRT(1,2),DISSYT,ICORE(I000),
     &              ICORE(I040),ICORE(I050),ICORE(I060))
        CALL PUTLST(ICORE(I000),1,NUMDSZ,1,IRREPZR,LISTZ)
C
       ENDIF
C
100   CONTINUE
C
      IF(IUHF.EQ.0)RETURN
C
C DO AAAA AND BBBB SPIN CASES
C
      DO 500 ISPIN=1,2
       DO 510 IRREPZR=1,NIRREP
        IRREPZL=DIRPRD(IRREPZR,IRREPX)
        IRREPTR=IRREPZR
        IRREPTL=IRREPZL
        LISTT=LISTT0-1+ISPIN
        LISTZ=LISTZ0-1+ISPIN
        DISSYZ=IRPDPD(IRREPZL,ISYTYP(1,LISTZ))
        NUMDSZ=IRPDPD(IRREPZR,ISYTYP(2,LISTZ))
        DISSYT=DISSYZ
        NUMDST=NUMDSZ
        MAXT=MAX(DISSYT,NUMDST)
        I000=1
        I010=I000+IINTFP*NUMDSZ*DISSYZ
        I020=I010+IINTFP*NUMDST*DISSYT
        I030=I020+IINTFP*NFMI(ISPIN)
        I040=I030+IINTFP*NFEA(ISPIN)
        I050=I040+IINTFP*MAXT
        I060=I050+IINTFP*MAXT
        I070=I060+IINTFP*MAXT
        CALL GETLST(ICORE(I010),1,NUMDST,1,IRREPTR,LISTT)
        CALL GETLST(ICORE(I020),1,1,1,ISPIN+IOFF,91)
        CALL GETLST(ICORE(I030),1,1,1,ISPIN+IOFF,92)
        CALL ZERO  (ICORE(I000),DISSYZ*NUMDSZ)
C
C CARRY OUT  CONTRACTION :
C
C    -T(AI,BM) * F(MJ) [RIGHT EIGENPROBLEM]
C
C                     +
C    -T(AI,BM) * F(JM) [LEFT EIGENPROBLEM]
C
        IOFFF=I020
        IOFFT=I010
        IOFFZ=I000
        DO 520 IRREPM=1,NIRREP
         IRREPJ=IRREPM
         IRREPB=DIRPRD(IRREPM,IRREPTR)
         NUMM=POP(IRREPM,ISPIN)
         NUMJ=POP(IRREPJ,ISPIN)
         NUMB=VRT(IRREPB,ISPIN)
         NROW=DISSYT*NUMB
         NCOL=NUMJ
         NSUM=NUMM
         IF(ISIDE.EQ.1)THEN
          CALL XGEMM('N','N',NROW,NCOL,NSUM,ONEM,ICORE(IOFFT),NROW,
     &               ICORE(IOFFF),NSUM,ZILCH,ICORE(IOFFZ),NROW)
         ELSE
          CALL XGEMM('N','T',NROW,NCOL,NSUM,ONEM,ICORE(IOFFT),NROW,
     &               ICORE(IOFFF),NCOL,ZILCH,ICORE(IOFFZ),NROW)
         ENDIF
         IOFFZ=IOFFZ+NROW*NCOL*IINTFP
         IOFFT=IOFFT+NROW*NSUM*IINTFP
         IOFFF=IOFFF+NUMM*NUMJ*IINTFP
520     CONTINUE
C
C NOW TRANSPOSE KET INDICES
C
        CALL SYMTR1(IRREPTR,VRT(1,ISPIN),POP(1,ISPIN),DISSYT,
     &              ICORE(I000),ICORE(I040),ICORE(I050),ICORE(I060))
        CALL SYMTR1(IRREPTR,VRT(1,ISPIN),POP(1,ISPIN),DISSYT,
     &              ICORE(I010),ICORE(I040),ICORE(I050),ICORE(I060))
C
C NOW CARRY OUT CONTRACTION :
C
C        T(AI,JE) * F(EB) [RIGHT EIGENPROBLEM]
C
C                        +
C        T(AI,JE) * F(BE) [LEFT EIGENPROBLEM]
C
        IOFFF=I030
        IOFFT=I010
        IOFFZ=I000
        DO 530 IRREPE=1,NIRREP
         IRREPB=IRREPE
         IRREPJ=DIRPRD(IRREPE,IRREPTR)
         NUMJ=POP(IRREPJ,ISPIN)
         NUME=VRT(IRREPE,ISPIN)
         NUMB=VRT(IRREPB,ISPIN)
         NROW=DISSYT*NUMJ
         NCOL=NUMB
         NSUM=NUME
         IF(ISIDE.EQ.1)THEN
          CALL XGEMM('N','N',NROW,NCOL,NSUM,ONE,ICORE(IOFFT),NROW,
     &               ICORE(IOFFF),NSUM,ONE,ICORE(IOFFZ),NROW)
         ELSE
          CALL XGEMM('N','T',NROW,NCOL,NSUM,ONE,ICORE(IOFFT),NROW,
     &               ICORE(IOFFF),NCOL,ONE,ICORE(IOFFZ),NROW)
         ENDIF
         IOFFT=IOFFT+NROW*NSUM*IINTFP
         IOFFF=IOFFF+NUME*NUMB*IINTFP
         IOFFZ=IOFFZ+NROW*NCOL*IINTFP
530     CONTINUE
C
C TRANSPOSE KET INDICES OF TARGET AND WRITE TO RING LISTS
C
        CALL SYMTR1(IRREPTR,POP(1,ISPIN),VRT(1,ISPIN),DISSYT,
     &              ICORE(I000),ICORE(I040),ICORE(I050),ICORE(I060))
        CALL SSCAL (NUMDSZ*DISSYZ,HALF,ICORE(I000),1)
        CALL PUTLST(ICORE(I000),1,NUMDSZ,1,IRREPZR,LISTZ)
510    CONTINUE
500   CONTINUE
C
      RETURN
      END
