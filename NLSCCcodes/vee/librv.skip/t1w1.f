      SUBROUTINE T1W1(ICORE,MAXCOR,IUHF,IRREPX,
     &                LISTR0,LISTT1,LISTW0,LISTZ0)
C
C THIS ROUTINE EVALUATES THE CONTRIBUTION
C
C  R(ab,ij) = P(ab) R(ef,ij) * T(b,m) * <ma||ef>
C
C THE T(b,m)*<ma||ef> PIECE IS FORMALLY A PART OF THE abef EFFECTIVE
C HAMILTONIAN, BUT THIS CODE IS REQUIRED IN CASES WHERE THESE MATRIX
C ELEMENTS ARE STORED EITHER AS THE MO INTEGRALS OR NOT STORED AT ALL.
C
CEND
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION ONE,ONEM,ZILCH
      DIMENSION ICORE(MAXCOR),IOFFZ0(8)
C
      COMMON/SYMINF/NSTART,NIRREP,IRREPY(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
C
      DATA ONE,ONEM,ZILCH /1.0D0,-1.0D0,0.0D0/   
C
C AAAA AND BBBB SPIN CASES FOR UHF
C
      IF(IUHF.NE.0)THEN
       DO 10 ISPIN=1,2
C
C Z(AB,IJ) = R(EF,IJ) * T(BM) * <EF||AM>
C
        LISTW=LISTW0+ISPIN
        LISTR=LISTR0+ISPIN
        LISTZ=LISTZ0+ISPIN
C
C                                               +
C FIRST FORM INTERMEDIATE Q(I<J,AM) = R(E<F,I<J) * W(E<F,AM)
C
        DO 20 IRREPAM=1,NIRREP
         IRREPIJ=DIRPRD(IRREPAM,IRREPX)
         IRREPAB=IRREPAM
         IRREPEF=IRREPAB
         DISSYR=IRPDPD(IRREPEF,ISYTYP(1,LISTR))
         NUMDSR=IRPDPD(IRREPIJ,ISYTYP(2,LISTR))
         DISSYW=IRPDPD(IRREPEF,ISYTYP(1,LISTW))
         NUMDSW=IRPDPD(IRREPAM,ISYTYP(2,LISTW))
         DISSYQ=NUMDSR
         NUMDSQ=NUMDSW
         DISSYZ=DISSYR
         NUMDSZ=NUMDSR
         DISSYZX=IRPDPD(IRREPAB,18+ISPIN)
C        
         I000=1
         I010=I000+MAX(DISSYZX*NUMDSZ,NUMDSQ*DISSYQ)*IINTFP
         I020=I010+MAX(DISSYZX*NUMDSZ,NUMDSR*DISSYR)*IINTFP
         CALL GETLST(ICORE(I010),1,NUMDSR,1,IRREPIJ,LISTR)
C
C PROCESS AS MANY AM DISTRIBUTIONS AS POSSIBLE
C
         MAXSIZE=MAXCOR-I020+1
         NINCOR=MAXSIZE/(MAX(1,DISSYW)*IINTFP)
         NLEFT=NUMDSW
         NFIRST=1
         NPASS=0
         IOFFQ=1
1        NREAD=MIN(NLEFT,NINCOR)
         CALL GETLST(ICORE(I020),NFIRST,NREAD,1,IRREPAM,LISTW)
C
C PERFORM MULTIPLICATION
C
C                   +
C         R(E<F,I<J) * W(E<F,AM) = Q(I<J,AM)
C
         CALL XGEMM('T','N',DISSYQ,NREAD,DISSYW,ONE,ICORE(I010),
     &              DISSYR,ICORE(I020),DISSYW,ZILCH,ICORE(IOFFQ),
     &              DISSYQ)
         IOFFQ=IOFFQ+IINTFP*NREAD*DISSYQ
         NFIRST=NFIRST+NREAD
         NLEFT=NLEFT-NREAD
         NPASS=NPASS+1
         IF(NLEFT.NE.0)GOTO 1
C
C NOW DO SECOND PART OF MULTIPLICATION
C
C                                    +
C       Z(I<J,AB) = Q(I<J,AM) * T(BM) 
C  
C FIRST GET OFFSETS FOR Z FOR EACH IRREP OF B
C
         IOFFZ0(1)=I010
         DO 21 IRREPB=1,NIRREP-1
          IRREPA=DIRPRD(IRREPB,IRREPAB)
          NUMA=VRT(IRREPA,ISPIN)
          NUMB=VRT(IRREPB,ISPIN)
          IOFFZ0(IRREPB+1)=IOFFZ0(IRREPB)+NUMDSZ*NUMA*NUMB*IINTFP
21       CONTINUE 
C        
         IOFFQ=I000
         IOFFT=I020
         CALL GETLST(ICORE(I020),1,1,1,ISPIN,LISTT1)
         DO 22 IRREPM=1,NIRREP
          IRREPA=DIRPRD(IRREPAM,IRREPM)
          IRREPB=IRREPM
          NUMA=VRT(IRREPA,ISPIN)
          NUMM=POP(IRREPM,ISPIN)
          NUMB=VRT(IRREPB,ISPIN)
          NROW=DISSYQ*NUMA
          NCOL=NUMB
          NSUM=NUMM
          IOFFZ=IOFFZ0(IRREPB)
          CALL XGEMM('N','T',NROW,NCOL,NSUM,ONE,ICORE(IOFFQ),NROW,
     &               ICORE(IOFFT),NCOL,ZILCH,ICORE(IOFFZ),NROW)
          IOFFQ=IOFFQ+IINTFP*NROW*NSUM
          IOFFT=IOFFT+IINTFP*NUMB*NUMM
22       CONTINUE
C
C ANTISYMMETRIZE AND AUGMENT LIST
C
         CALL ASSYM2(IRREPAB,VRT(1,ISPIN),NUMDSZ,ICORE(I010))
         CALL TRANSP(ICORE(I010),ICORE(I000),DISSYZ,NUMDSZ)
         CALL GETLST(ICORE(I010),1,NUMDSZ,1,IRREPIJ,LISTZ)
         CALL SAXPY (NUMDSZ*DISSYZ,ONEM,ICORE(I000),1,ICORE(I010),1)
         CALL PUTLST(ICORE(I010),1,NUMDSZ,1,IRREPIJ,LISTZ)
20      CONTINUE
10     CONTINUE 
      ENDIF
C
C NOW HANDLE ABAB SPIN CASE
C
C
C Z(Ab,Ij) = R(Ef,Ij) * T(bm) * <Ef|Ma> + R(Ef,Ij) * T(AM) * <Ef|Mb>
C
      LISTR=LISTR0+3
      LISTZ=LISTZ0+3
C
C                                            +
C FIRST FORM INTERMEDIATE Q(Ij,Am) = R(Ef,Ij) * W(Ef,Am)
C
      DO 120 IRREPAM=1,NIRREP
       LISTW=LISTW0+4
       IRREPIJ=DIRPRD(IRREPAM,IRREPX)
       IRREPAB=IRREPAM
       IRREPEF=IRREPAB
       DISSYR=IRPDPD(IRREPEF,ISYTYP(1,46))
       NUMDSR=IRPDPD(IRREPIJ,ISYTYP(2,46))
       DISSYQ=IRPDPD(IRREPIJ,ISYTYP(2,46))
       NUMDSQ=IRPDPD(IRREPAM,ISYTYP(1,25))
       DISSYW=IRPDPD(IRREPEF,ISYTYP(1,LISTW))
       NUMDSW=IRPDPD(IRREPAM,ISYTYP(2,LISTW))
       DISSYZ=DISSYR
       NUMDSZ=NUMDSR
       I000=1
       I010=I000+MAX(DISSYZ*NUMDSZ,NUMDSQ*DISSYQ)*IINTFP
       I020=I010+MAX(DISSYZ*NUMDSZ,NUMDSR*DISSYR)*IINTFP
       CALL GETLST(ICORE(I010),1,NUMDSR,1,IRREPIJ,LISTR)
C
C PROCESS AS MANY Am DISTRIBUTIONS AS POSSIBLE
C
       MAXSIZE=MAXCOR-I020+1
       NINCOR=MAXSIZE/(MAX(1,DISSYW)*IINTFP)
       NLEFT=NUMDSW
       NFIRST=1
       NPASS=0
       IOFFQ=1
2      NREAD=MIN(NLEFT,NINCOR)
       CALL GETLST(ICORE(I020),NFIRST,NREAD,1,IRREPAM,LISTW)
C
C PERFORM MULTIPLICATION
C
C                 +
C         R(Ef,Ij) * W(Ef,Am) = Q(Ij,Am)
C
       CALL XGEMM('T','N',DISSYQ,NREAD,DISSYW,ONE,ICORE(I010),
     &            DISSYR,ICORE(I020),DISSYW,ZILCH,ICORE(IOFFQ),
     &            DISSYQ)
       IOFFQ=IOFFQ+IINTFP*NREAD*DISSYQ
       NFIRST=NFIRST+NREAD
       NLEFT=NLEFT-NREAD
       NPASS=NPASS+1
       IF(NLEFT.NE.0)GOTO 2
C
C NOW DO SECOND PART OF MULTIPLICATION
C
C                                  +
C       Z(Ij,Ab) = Q(Ij,Am) * T(bm) 
C  
C FIRST GET OFFSETS FOR Z FOR EACH IRREP OF B
C
       IOFFZ0(1)=I010
       DO 121 IRREPB=1,NIRREP-1
        IRREPA=DIRPRD(IRREPB,IRREPAB)
        NUMA=VRT(IRREPA,1)
        NUMB=VRT(IRREPB,2)
        IOFFZ0(IRREPB+1)=IOFFZ0(IRREPB)+NUMDSZ*NUMA*NUMB*IINTFP
121    CONTINUE 
C        
       IOFFQ=I000
       IOFFT=I020
       CALL GETLST(ICORE(I020),1,1,1,1+IUHF,LISTT1)
       DO 122 IRREPM=1,NIRREP
        IRREPA=DIRPRD(IRREPAM,IRREPM)
        IRREPB=IRREPM
        NUMA=VRT(IRREPA,1)
        NUMM=POP(IRREPM,2)
        NUMB=VRT(IRREPB,2)
        NROW=DISSYQ*NUMA
        NCOL=NUMB
        NSUM=NUMM
        IOFFZ=IOFFZ0(IRREPB)
        CALL XGEMM('N','T',NROW,NCOL,NSUM,ONE,ICORE(IOFFQ),NROW,
     &             ICORE(IOFFT),NCOL,ZILCH,ICORE(IOFFZ),NROW)
        IOFFQ=IOFFQ+IINTFP*NROW*NSUM
        IOFFT=IOFFT+IINTFP*NUMB*NUMM
122    CONTINUE
C
C SYMMETRIZE FOR RHF
C
       CALL TRANSP(ICORE(I010),ICORE(I000),DISSYZ,NUMDSZ)
       IF(IUHF.EQ.0)THEN
        MAXZ=MAX(DISSYZ,NUMDSZ)
        ITMP1=I020
        ITMP2=ITMP1+IINTFP*MAXZ
        ITMP3=ITMP2+IINTFP*MAXZ
        CALL SYMRHF3(IRREPAB,IRREPIJ,VRT(1,1),POP(1,1),
     &               DISSYZ,ICORE(I000),ICORE(ITMP1),
     &               ICORE(ITMP2),ICORE(ITMP3))
       ENDIF 
       CALL GETLST(ICORE(I010),1,NUMDSZ,1,IRREPIJ,LISTZ)
       CALL SAXPY (NUMDSZ*DISSYZ,ONEM,ICORE(I000),1,ICORE(I010),1)
       CALL PUTLST(ICORE(I010),1,NUMDSZ,1,IRREPIJ,LISTZ)
       IF(IUHF.NE.0)THEN
C
C NEED TO DO ANOTHER CONTRACTION FOR UHF CASES - BABA SPIN CASE
C
C
C Z(Ab,Ij) = Z(Ab,Ij) + R(Ef,Ij) * T(AM) * <Ef|Mb>
C
        IRREPMB=IRREPAM
        LISTW=LISTW0+3
        IRREPIJ=DIRPRD(IRREPMB,IRREPX)
        IRREPAB=IRREPMB
        IRREPEF=IRREPAB
        DISSYR=IRPDPD(IRREPEF,ISYTYP(1,LISTR))
        NUMDSR=IRPDPD(IRREPIJ,ISYTYP(2,LISTR))
        DISSYQ=IRPDPD(IRREPIJ,ISYTYP(2,LISTR))
        NUMDSQ=IRPDPD(IRREPMB,ISYTYP(2,LISTW))
        DISSYW=IRPDPD(IRREPEF,ISYTYP(1,LISTW))
        NUMDSW=IRPDPD(IRREPMB,ISYTYP(2,LISTW))
        DISSYZ=DISSYR
        NUMDSZ=NUMDSR
        MAXTMP=MAX(DISSYZ,NUMDSZ,DISSYQ,NUMDSQ)
        I000=1
        I010=I000+MAX(DISSYZ*NUMDSZ,NUMDSQ*DISSYQ)*IINTFP
        I020=I010+MAX(DISSYZ*NUMDSZ,NUMDSR*DISSYR)*IINTFP
        ITMP1=I010
        ITMP2=ITMP1+MAXTMP*IINTFP
        ITMP3=ITMP2+MAXTMP*IINTFP
        CALL GETLST(ICORE(I010),1,NUMDSR,1,IRREPIJ,LISTR)
C
C PROCESS AS MANY Mb DISTRIBUTIONS AS POSSIBLE
C
        MAXSIZE=MAXCOR-I020+1
        NINCOR=MAXSIZE/(MAX(1,DISSYW)*IINTFP)
        NLEFT=NUMDSW
        NFIRST=1
        NPASS=0
        IOFFQ=1
3       NREAD=MIN(NLEFT,NINCOR)
        CALL GETLST(ICORE(I020),NFIRST,NREAD,1,IRREPMB,LISTW)
C
C PERFORM MULTIPLICATION
C
C                 +
C         R(Ef,Ij) * W(Ef,Mb) = Q(Ij,Mb)
C
        CALL XGEMM('T','N',DISSYQ,NREAD,DISSYW,ONE,ICORE(I010),
     &             DISSYR,ICORE(I020),DISSYW,ZILCH,ICORE(IOFFQ),
     &             DISSYQ)
        IOFFQ=IOFFQ+IINTFP*NREAD*DISSYQ
        NFIRST=NFIRST+NREAD
        NLEFT=NLEFT-NREAD
        NPASS=NPASS+1
        IF(NLEFT.NE.0)GOTO 3
C
C REARRANGE Q(Ij,Mb) -> Q(Ij,bM)
C
        CALL SYMTR1(IRREPMB,POP(1,1),VRT(1,2),DISSYQ,ICORE(I000),
     &              ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
C
C NOW DO SECOND PART OF MULTIPLICATION
C
C                                  +
C       Z(Ij,bA) = Q(Ij,bM) * T(AM) 
C  
C FIRST GET OFFSETS FOR Z FOR EACH IRREP OF A
C
        IOFFZ0(1)=I010
        DO 221 IRREPA=1,NIRREP-1
         IRREPB=DIRPRD(IRREPA,IRREPAB)
         NUMA=VRT(IRREPA,1)
         NUMB=VRT(IRREPB,2)
         IOFFZ0(IRREPA+1)=IOFFZ0(IRREPA)+NUMDSZ*NUMA*NUMB*IINTFP
221     CONTINUE 
C        
        IOFFQ=I000
        IOFFT=I020
        CALL GETLST(ICORE(I020),1,1,1,1,LISTT1)
        DO 222 IRREPM=1,NIRREP
         IRREPB=DIRPRD(IRREPMB,IRREPM)
         IRREPA=IRREPM
         NUMA=VRT(IRREPA,1)
         NUMM=POP(IRREPM,1)
         NUMB=VRT(IRREPB,2)
         NROW=DISSYQ*NUMB
         NCOL=NUMA
         NSUM=NUMM
         IOFFZ=IOFFZ0(IRREPA)
         CALL XGEMM('N','T',NROW,NCOL,NSUM,ONE,ICORE(IOFFQ),NROW,
     &              ICORE(IOFFT),NCOL,ZILCH,ICORE(IOFFZ),NROW)
         IOFFQ=IOFFQ+IINTFP*NROW*NSUM
         IOFFT=IOFFT+IINTFP*NUMA*NUMM
222     CONTINUE
C
C REORDER Z(Ij,bA) -> Z(Ij,Ab)
C
        CALL TRANSP(ICORE(I010),ICORE(I000),DISSYZ,NUMDSZ) 
        CALL SYMTR3(IRREPAB,VRT(1,2),VRT(1,1),DISSYZ,NUMDSZ,
     &              ICORE(I000),ICORE(ITMP1),ICORE(ITMP2),
     &              ICORE(ITMP3))
        CALL GETLST(ICORE(I010),1,NUMDSZ,1,IRREPIJ,LISTZ)
        CALL SAXPY (NUMDSZ*DISSYZ,ONEM,ICORE(I000),1,ICORE(I010),1)
        CALL PUTLST(ICORE(I010),1,NUMDSZ,1,IRREPIJ,LISTZ)
       ENDIF
120   CONTINUE
C
      RETURN
      END 
