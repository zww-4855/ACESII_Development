      SUBROUTINE TPDIJKA1(ICORE,MAXCOR,IUHF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,DISSYG,DISSYR,POP,VRT
      DIMENSION ICORE(MAXCOR)
      DIMENSION I0T(2),I0R(2),I0L(2),IOFFRR(8,2),IOFFGG(8)
C
C CALCULATION OF THE FIRST IJKA CONTRIBUTION TO
C THE EOM-CCSD TWO-PARTICLE DENSITY MATRIX
C
C          - 1/2 R(IJ,EA) L(K,E) - R(I,E) L(K,E) T(J,A)
C
C          - T(I,E) L(K,E) R(J,A)
C
CEND 
C
C CODED JG SEPTEMBER/93
C
      COMMON/STATSYM/IRREPX
      COMMON/SYMINF/NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
C
      DATA AZERO,HALF,HALFM,ONE,TWO /0.D0,0.5D0,-0.5D0,1.0D0,2.0D0/
C
C READ IN T1, R1, AND L1 AMPLITUDES
C
      I0T(1)=1
      I0T(2)=I0T(1)+IRPDPD(1,9)*IINTFP*IUHF
      I0R(1)=I0T(2)+IRPDPD(1,10)*IINTFP
      I0R(2)=I0R(1)+IRPDPD(IRREPX,9)*IINTFP*IUHF
      I0L(1)=I0R(2)+IRPDPD(IRREPX,10)*IINTFP
      I0L(2)=I0L(1)+IRPDPD(IRREPX,9)*IINTFP*IUHF
      ISTART=I0L(2)+IRPDPD(IRREPX,10)*IINTFP
C
      CALL GETLST(ICORE(I0R(1)),1,1,1,3,490)
      CALL GETLST(ICORE(I0L(1)),1,1,1,1,490)
      CALL GETLST(ICORE(I0T(1)),1,1,1,1,90)
      IF(IUHF.EQ.1) THEN
       CALL GETLST(ICORE(I0R(2)),1,1,1,4,490)
       CALL GETLST(ICORE(I0L(2)),1,1,1,2,490)
       CALL GETLST(ICORE(I0T(2)),1,1,1,2,90)
      ENDIF
C
C GET OFFSET FOR R1 AND L1
C
      DO 1 ISPIN=1,2
       IOFF=0
       DO 2 IRREPR=1,NIRREP
        IRREPL=DIRPRD(IRREPX,IRREPR)
        IOFFRR(IRREPR,ISPIN)=IOFF
        IOFF=IOFF+IINTFP*VRT(IRREPL,ISPIN)*POP(IRREPR,ISPIN)
2      CONTINUE
1     CONTINUE
C
C AAAA AND BBBB SPIN CASES (UHF ONLY)
C
      IF(IUHF.EQ.1) THEN
C
       DO 1000 ISPIN=1,2
C
        LISTG=106+ISPIN
        LISTR=460+ISPIN
C
        DO 100 IRREPR=1,NIRREP
C
         IRREPL=DIRPRD(IRREPR,IRREPX) 
C
         NUMSYG=IRPDPD(IRREPR,ISYTYP(2,LISTG)) 
         DISSYG=IRPDPD(IRREPR,ISYTYP(1,LISTG))
         NUMSYR=IRPDPD(IRREPR,ISYTYP(2,LISTR))
         DISSYR=IRPDPD(IRREPL,ISYTYP(1,LISTR))
         NVRTSQ=IRPDPD(IRREPL,18+ISPIN)
C
C ALLOCATE MEMORY
C
         I000=ISTART
         I010=I000+IINTFP*NUMSYG*DISSYG
         I020=I010+IINTFP*MAX(NUMSYG*DISSYG,NUMSYR*NVRTSQ)
         ITMP=I020+IINTFP*NUMSYR*DISSYR
         IEND=ITMP+IINTFP*3*MAX(DISSYG,DISSYR,NUMSYG,NUMSYR)
         IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA',IEND,MAXCOR)
C
C GET OFFSETS FOR G
C
         IOFF=0
         DO 101 IRREPRR=1,NIRREP
          IRREPRL=DIRPRD(IRREPRR,IRREPR)
          IOFFGG(IRREPRR)=IOFF
          IOFF=IOFF+IINTFP*DISSYG*VRT(IRREPRL,ISPIN)
     &                           *POP(IRREPRR,ISPIN)
101      CONTINUE
C
C GET R AMPLITUDES
C
         CALL GETLST(ICORE(I020),1,NUMSYR,1,IRREPR,LISTR)
C
C FORM R(TWIDDLE)
C
         CALL DTAU(IRREPL,IRREPR,1,IRREPX,ICORE(I020),
     &             ICORE(I0T(ISPIN)),ICORE(I0T(ISPIN)),
     &             ICORE(I0R(ISPIN)),ICORE(I0R(ISPIN)),
     &             ISPIN,ONE)
C
C TRANSPOSE R(TWIDDLE)
C
         CALL TRANSP(ICORE(I020),ICORE(I010),NUMSYR,DISSYR)
C
C EXPAND RIGHT-HAND SIDE OF L AMPLITUDES
C
         CALL SYMEXP(IRREPL,VRT(1,ISPIN),NUMSYR,ICORE(I010))
C
C PERFORM MULTIPLICATION
C
         IOFFR=0
C
         DO 10 IRREPE=1,NIRREP
          IRREPA=DIRPRD(IRREPL,IRREPE)
          IRREPI=DIRPRD(IRREPE,IRREPX)
          NVRTA=VRT(IRREPA,ISPIN)
          NVRTE=VRT(IRREPE,ISPIN)
          NOCCI=POP(IRREPI,ISPIN)
C
          IOFFL=IOFFRR(IRREPI,ISPIN)
          IOFFG=IOFFGG(IRREPI)
C
          CALL XGEMM('N','N',NUMSYR*NVRTA,NOCCI,NVRTE,HALF,
     &               ICORE(I010+IOFFR),NUMSYR*NVRTA,ICORE(I0L(ISPIN)
     &               +IOFFL),NVRTE,AZERO,ICORE(I000+IOFFG),DISSYG*NVRTA)
C
          IOFFR=IOFFR+IINTFP*NUMSYR*NVRTA*NVRTE
C
10       CONTINUE
C
C TRANSPOSE THIRD AND FOURTH INDEX TO GET G(IJ,KA)
C
         CALL SYMTR1(IRREPR,VRT(1,ISPIN),POP(1,ISPIN),
     &               DISSYG,ICORE(I000),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYG),
     &               ICORE(ITMP+2*IINTFP*DISSYG))
C
C SAVE G(IJ,KA) ON DISK   (UPDATE ???)
C
         call checksum('tpdijka1',icore(i000),numsyg*dissyg,s)
         CALL GETLST(ICORE(I010),1,NUMSYG,1,IRREPR,LISTG)
         CALL SAXPY (NUMSYG*DISSYG,ONE,ICORE(I010),1,ICORE(I000),1)
         CALL PUTLST(ICORE(I000),1,NUMSYG,1,IRREPR,LISTG)
C
100     CONTINUE
C
1000   CONTINUE
C
      ENDIF
C
C ABAB AND BABA SPIN CASE
C
      DO 2000 ISPIN=1,IUHF+1
C
       LISTG=111-ISPIN
       LISTR=463
C
       DO 1100 IRREPR=1,NIRREP
C
        IRREPL=DIRPRD(IRREPR,IRREPX) 
C
        NUMSYG=IRPDPD(IRREPR,ISYTYP(2,LISTG)) 
        DISSYG=IRPDPD(IRREPR,ISYTYP(1,LISTG))
        NUMSYR=IRPDPD(IRREPR,ISYTYP(2,LISTR))
        DISSYR=IRPDPD(IRREPL,ISYTYP(1,LISTR))
C
C ALLOCATE MEMORY
C
        I000=ISTART
        I010=I000+IINTFP*NUMSYG*DISSYG
        I020=I010+IINTFP*MAX(NUMSYG*DISSYG,NUMSYR*DISSYR)
        ITMP=I020+IINTFP*NUMSYR*DISSYR
        IEND=ITMP+IINTFP*3*MAX(DISSYR,NUMSYR,DISSYG,NUMSYG)
        IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA',IEND,MAXCOR)
C
C GET OFFSETS FOR G
C
        IOFF=0
        DO 1101 IRREPRR=1,NIRREP
         IRREPRL=DIRPRD(IRREPRR,IRREPR)
         IOFFGG(IRREPRR)=IOFF
         IOFF=IOFF+IINTFP*DISSYG*VRT(IRREPRL,3-ISPIN)
     &                          *POP(IRREPRR,ISPIN)
1101    CONTINUE
C
C GET R AMPLITUDES
C
         CALL GETLST(ICORE(I020),1,NUMSYR,1,IRREPR,LISTR)
C
C FORM R(TWIDDLE)
C
         CALL DTAU(IRREPL,IRREPR,1,IRREPX,ICORE(I020),
     &             ICORE(I0T(1)),ICORE(I0T(2)),
     &             ICORE(I0R(1)),ICORE(I0R(2)),
     &             3,ONE)
C
C TRANSPOSE R(TWIDDLE)
C
         CALL TRANSP(ICORE(I020),ICORE(I010),NUMSYR,DISSYR)
C
C FOR ISPIN=1 INTERCHANGE A AND B
C
        IF(ISPIN.EQ.1) THEN
         CALL SYMTR1(IRREPL,VRT(1,1),VRT(1,2),NUMSYR,ICORE(I010),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYR),
     &               ICORE(ITMP+2*IINTFP*NUMSYR))
        ENDIF
C
C PERFORM MULTIPLICATION
C
        IOFFR=0
C
        DO 110 IRREPE=1,NIRREP
         IRREPA=DIRPRD(IRREPL,IRREPE)
         IRREPI=DIRPRD(IRREPE,IRREPX)
         NVRTA=VRT(IRREPA,3-ISPIN)
         NVRTE=VRT(IRREPE,ISPIN)
         NOCCI=POP(IRREPI,ISPIN)
C
         IOFFL=IOFFRR(IRREPI,ISPIN)
         IOFFG=IOFFGG(IRREPI)
C
         CALL XGEMM('N','N',NUMSYR*NVRTA,NOCCI,NVRTE,HALFM,
     &              ICORE(I010+IOFFR),NUMSYR*NVRTA,ICORE(I0L(ISPIN)
     &              +IOFFL),NVRTE,AZERO,ICORE(I000+IOFFG),DISSYG*NVRTA) 
C
         IOFFR=IOFFR+IINTFP*NUMSYR*NVRTA*NVRTE
C
110     CONTINUE
C
C TRANSPOSE THIRD AND FOURTH INDEX TO GET G(JK,IA) (ONLY FOR ISPIN=1)
C
        IF(ISPIN.EQ.1) THEN
         CALL SYMTR1(IRREPR,VRT(1,2),POP(1,1),DISSYG,ICORE(I000),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYG),
     &               ICORE(ITMP+2*IINTFP*DISSYG))
        ENDIF
C
C SAVE G(IJ,KA) ON DISK   (OR UPDATE ???)
C
        call checksum('tpdijka1',icore(i000),numsyg*dissyg,s)
        CALL GETLST(ICORE(I010),1,NUMSYG,1,IRREPR,LISTG)
        CALL SAXPY (NUMSYG*DISSYG,ONE,ICORE(I010),1,ICORE(I000),1)
        CALL PUTLST(ICORE(I000),1,NUMSYG,1,IRREPR,LISTG)
C
1100   CONTINUE
C
2000  CONTINUE
C
C ALL DONE, RETURN
C
      TWO=0.D0
      IF(IUHF.EQ.0)
     &   CALL CHECKGAM1(ICORE,10,110,TWO,IUHF,2,POP)
      IF(IUHF.EQ.1) THEN
       CALL CHECKGAM(ICORE,10,110,TWO)
       CALL CHECKGAM(ICORE,7,107,TWO)
       CALL CHECKGAM(ICORE,8,108,TWO)
       CALL CHECKGAM(ICORE,9,109,TWO)
      ENDIF
C
      RETURN
      END
