      SUBROUTINE TPDIJKL(ICORE,MAXCOR,IUHF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,DISSYZ,POP,VRT
      LOGICAL MBPT2,CC,CCD,RCCD,DRCCD,LCCD,LCCSD,CC2
      LOGICAL SS, SD, DS, DD
      DIMENSION ICORE(MAXCOR)
      DIMENSION I0T(2),I0R(2)
C
C CALCULATION OF THE IJKL CONTRIBUTION TO
C THE EOM-CCSD TWO-PARTICLE DENSITY MATRIX
C
C G(IJ,KL) = 1/8 R(IJ,EF) L(KL,EF) + 1/2 R(I,E) L(KL,EF) T(J,F)
C
C          = 1/8 {R(IJ,EF) + R(I,E) T(J,F) + T(I,E) R(J,F)
C
C                 - R(I,F) T(J,E) - T(I,F) R(J,E)} L(KL,EF)
C
C NOTE THAT 4*G(IJ,KL) IS CALCULATED
C
CEND 
C
C CODED JG SEPTEMBER/93
C
      COMMON/STATSYM/IRREPX
      COMMON/SYMINF/NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/REFTYPE/MBPT2,CC,CCD,RCCD,DRCCD,LCCD,LCCSD,CC2
      COMMON/DRVHBAR/SS, SD, DS, DD
C
      DATA AZERO,ONE/0.D0,1.D0/
C SG 9/96 This term is not needed for P-EOM-MBPT(2)
      IF ((MBPT2 .OR. LCCD .OR. LCCSD .OR. RCCD .OR. DRCCD)
     &     .AND. .NOT.DD) THEN

        DO 10 ISPIN=3-2*IUHF,3
          LISTG=110+ISPIN
          CALL ZEROLIST(ICORE,MAXCOR,LISTG)
 10     CONTINUE
        GOTO 500
      ENDIF
C
C READ IN T1 AND R1 AMPLITUDES
C
      I0T(1)=1
      I0T(2)=I0T(1)+IRPDPD(1,9)*IINTFP*IUHF
      I0R(1)=I0T(2)+IRPDPD(1,10)*IINTFP
      I0R(2)=I0R(1)+IRPDPD(IRREPX,9)*IINTFP*IUHF
      ISTART=I0R(2)+IRPDPD(IRREPX,10)*IINTFP
C
      CALL GETLST(ICORE(I0T(1)),1,1,1,1,90)
      CALL GETLST(ICORE(I0R(1)),1,1,1,3,490)
      IF(IUHF.EQ.1) THEN
       CALL GETLST(ICORE(I0T(2)),1,1,1,2,90)
       CALL GETLST(ICORE(I0R(2)),1,1,1,4,490)
      ENDIF
C 
C LOOP OVER ALL SPIN CASES
C
      DO 1000 ISPIN=3-2*IUHF,3
C  
       DO 100 IRREPR=1,NIRREP
C
        IRREPL=DIRPRD(IRREPX,IRREPR)
C
        LISTR=460+ISPIN
        LISTL=443+ISPIN
        LISTG=110+ISPIN
C
        DISSYZ=IRPDPD(IRREPL,ISYTYP(1,LISTR))
        NUMSYZ=IRPDPD(IRREPR,ISYTYP(2,LISTR))
C
C ALLOCATE MEMORY
C
        I000=ISTART
        I010=I000+IINTFP*NUMSYZ*NUMSYZ
        I020=I010+IINTFP*DISSYZ*NUMSYZ
        I030=I020+IINTFP*DISSYZ*NUMSYZ
C
C READ IN R2 AMPLITUDES
C
        IF (CC2) THEN
           CALL ZERO(ICORE(I010),NUMSYZ*DISSYZ)
        ELSE
           CALL GETLST(ICORE(I010),1,NUMSYZ,1,IRREPR,LISTR)
        ENDIF 
C
C ADD T1*R1 CONTRIBUTION TO R2
C
        IF(ISPIN.LE.2) THEN
         CALL DTAU(IRREPL,IRREPR,1,IRREPX,ICORE(I010),
     &             ICORE(I0T(ISPIN)),ICORE(I0T(ISPIN)),
     &             ICORE(I0R(ISPIN)),ICORE(I0R(ISPIN)),ISPIN,ONE)
        ELSE
         CALL DTAU(IRREPL,IRREPR,1,IRREPX,ICORE(I010),
     &             ICORE(I0T(1)),ICORE(I0T(2)),ICORE(I0R(1)),
     &             ICORE(I0R(2)),ISPIN,ONE)
        ENDIF
C
C GET L2 AMPLITUDES
C
        CALL GETLST(ICORE(I020),1,NUMSYZ,1,IRREPR,LISTL)
C
C PERFORM MULTIPLICATION TO GET G(IJ,KL)
C
        CALL XGEMM('T','N',NUMSYZ,NUMSYZ,DISSYZ,ONE,ICORE(I010),DISSYZ,
     &             ICORE(I020),DISSYZ,AZERO,ICORE(I000),NUMSYZ)
C
C SAVE G(IJ,KL) ON DISK
C
C SYMMETRIZE G(IJ,KL)   ( = 1/2 (G(IJ,KL) + G(KL,IJ)))
C
        call checksum('tpdijkl',icore(i000),numsyz*numsyz,s)
        CALL SYMMET2(ICORE(I000),NUMSYZ)
C
        call checksum('tpdijkl',icore(i000),numsyz*numsyz,s)
        CALL PUTLST(ICORE(I000),1,NUMSYZ,1,IRREPR,LISTG)
C
100    CONTINUE
C
1000  CONTINUE
C
C ALL DONE, RETURN
C 
 500  CONTINUE
      if(iuhf.eq.0) then
      call checkgam1(icore,13,113,ONE,IUHF,1,POP)
      endif 
      if(iuhf.eq.1) then
       call checkgam(icore,13,113,ONE)
       call checkgam(icore,11,111,ONE)
       call checkgam(icore,12,112,ONE)
      endif
      RETURN
      END
