      SUBROUTINE TPDABCI2(ICORE,MAXCOR,IUHF)
C
C CALCULATION OF THE THIRD ABCI CONTRIBUTION TO
C THE EOM-CCSD TWO-PARTICLE DENSITY MATRIX
C
C G(AB,CI) = 1/2 [L(MN,CE)*T(I,E)]* RTAU(MN,AB)
C
C ALSO, ONLY THE SUM OF G(AB,CI) AND G(AI,BC) IS STORED ON DISK
C
CEND 
C
C CODED JG SEPTEMBER/93
C
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION ZILCH,HALFM,ONE,TWO
      LOGICAL MBPT2,CC,CCD,RCCD,DRCCD,LCCD,LCCSD,CC2
      DIMENSION ICORE(MAXCOR),I0T(2),I0R(2)
      COMMON/STATSYM/IRREPX
      COMMON/SYMINF/NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMLOC/ISYMOFF(8,8,25)
      COMMON/REFTYPE/MBPT2,CC,CCD,RCCD,DRCCD,LCCD,LCCSD,CC2
C
      DATA ZILCH,HALFM,ONE /0.D0,-0.5D0,1.0D0/
C
C READ IN R1 AND T1 AMPLITUDES
C
      I0T(1)=1
      I0T(2)=I0T(1)+IRPDPD(1,9)*IINTFP*IUHF
      I0R(1)=I0T(2)+IRPDPD(1,10)*IINTFP
      I0R(2)=I0R(1)+IRPDPD(IRREPX,9)*IINTFP*IUHF
      ISTART=I0R(2)+IRPDPD(IRREPX,10)*IINTFP
C
      CALL GETLST(ICORE(I0T(1)),1,1,1,1,90)
      CALL GETLST(ICORE(I0R(1)),1,1,1,3,490)
      IF(IUHF.EQ.1) THEN
       CALL GETLST(ICORE(I0T(2)),1,1,1,2,90)
       CALL GETLST(ICORE(I0R(2)),1,1,1,4,490)
      ENDIF
C
      DO 10 ISPIN=4,4-3*IUHF,-1
       LISTL=443+MIN(ISPIN,3)
       LISTR=460+MIN(ISPIN,3)
       LISTG=126+ISPIN
       DO 100 IRREPR=1,NIRREP
        IRREPL=DIRPRD(IRREPR,IRREPX)
        DISSYL=IRPDPD(IRREPL,ISYTYP(1,LISTL))
        IF(ISPIN.LT.3)THEN
         DISSYLX=IRPDPD(IRREPL,18+ISPIN)
        ELSE
         DISSYLX=DISSYL
        ENDIF
        NUMDSL=IRPDPD(IRREPR,ISYTYP(2,LISTL))
        DISSYR=IRPDPD(IRREPL,ISYTYP(1,LISTR))
        NUMDSR=IRPDPD(IRREPR,ISYTYP(2,LISTR))
        DISSYG=IRPDPD(IRREPL,ISYTYP(1,LISTG))
        NUMDSG=IRPDPD(IRREPL,ISYTYP(2,LISTG))
        MAXT=MAX(DISSYL,DISSYG,DISSYR,NUMDSL,NUMDSG,NUMDSR,DISSYLX)
C
        I000=ISTART
        I010=I000+IINTFP*MAX(DISSYLX*NUMDSL,DISSYR*NUMDSR,3*MAXT)
        I020=I010+IINTFP*MAX(DISSYL*NUMDSL,NUMDSL*NUMDSG,
     &                       DISSYR*NUMDSR,3*MAXT)
C
C READ IN L(CE,MN), TRANSPOSE TO L(MN,CE) AND EXPAND RIGHT SIDE TO
C FULL STORAGE FOR ISPIN.LE.2 OR TRANSPOSE TO L(Mn,eC) FOR ISPIN=3.
C
        CALL GETLST(ICORE(I010),1,NUMDSL,1,IRREPR,LISTL)
        CALL TRANSP(ICORE(I010),ICORE(I000),NUMDSL,DISSYL)
        IF(ISPIN.LT.3)THEN
         CALL SYMEXP(IRREPL,VRT(1,ISPIN),NUMDSL,ICORE(I000))
        ELSEIF(ISPIN.EQ.3)THEN
         ITMP1=I010
         ITMP2=ITMP1+IINTFP*MAXT
         ITMP3=ITMP2+IINTFP*MAXT
         CALL SYMTR1(IRREPL,VRT(1,1),VRT(1,2),NUMDSL,ICORE(I000),
     &               ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
        ENDIF
C
C FORM PRODUCT:
C
C            Q(M<N,CI) = L(M<N,CE)*T(EI) [ISPIN=1 OR 2]
C            Q(Mn,cI)  = L(Mn,cE)*T(EI)  [ISPIN=3]
C            Q(Mn,Ci)  = L(Mn,Ce)*T(ei)  [ISPIN=4]
C
        DO 111 IRREPI=1,NIRREP
         IRREPE=IRREPI
         IRREPC=DIRPRD(IRREPE,IRREPL)
         IF(ISPIN.LE.2)THEN
          ISPINR=ISPIN
          ISPINC=ISPIN
          ITL=18+ISPIN
          ITQ=8+ISPIN
         ELSEIF(ISPIN.EQ.3)THEN
          ISPINR=1
          ISPINC=2
          ITL=23
          ITQ=12
         ELSEIF(ISPIN.EQ.4)THEN
          ISPINR=2
          ISPINC=1
          ITL=13
          ITQ=11
         ENDIF
         NUMI=POP(IRREPI,ISPINR)
         NUMC=VRT(IRREPC,ISPINC)
         NUME=VRT(IRREPE,ISPINR)
         NROW=NUMDSL*NUMC
         NCOL=NUMI
         NSUM=NUME
         IOFFL=I000+(ISYMOFF(IRREPE,IRREPL,ITL)-1)*NUMDSL*IINTFP
         IOFFQ=I010+(ISYMOFF(IRREPI,IRREPL,ITQ)-1)*NUMDSL*IINTFP
         IOFFT=I0T(ISPINR)+(ISYMOFF(IRREPI,1,8+ISPINR)-1)*IINTFP
         CALL XGEMM('N','N',NROW,NCOL,NSUM,ONE,ICORE(IOFFL),NROW,
     &              ICORE(IOFFT),NSUM,ZILCH,ICORE(IOFFQ),NROW)
111     CONTINUE
C
C Q(Mn,cI) -> Q(Mn,Ic)  [ISPIN=3]
C
        IF(ISPIN.EQ.3)THEN 
         ITMP1=I000
         ITMP2=ITMP1+IINTFP*MAXT
         ITMP3=ITMP2+IINTFP*MAXT
         CALL SYMTR1(IRREPL,VRT(1,2),POP(1,1),NUMDSL,ICORE(I010),
     &               ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
        ENDIF
C
C READ IN R(MN,AB) AND MAKE CORRESPONDING TAU AMPLITUDES
C
        IF (CC2) THEN
        CALL ZERO(ICORE(I000),NUMDSR*DISSYR)
        ELSE
        CALL GETLST(ICORE(I000),1,NUMDSR,1,IRREPR,LISTR) 
        ENDIF 

        IF(ISPIN.LE.2) THEN
         CALL DTAU(IRREPL,IRREPR,IRREPX,1,ICORE(I000),
     &             ICORE(I0R(ISPIN)),ICORE(I0R(ISPIN)),
     &             ICORE(I0T(ISPIN)),ICORE(I0T(ISPIN)),
     &             ISPIN,ONE)
        ELSE
         CALL DTAU(IRREPL,IRREPR,IRREPX,1,ICORE(I000),
     &             ICORE(I0R(1)),ICORE(I0R(2)),
     &             ICORE(I0T(1)),ICORE(I0T(2)),
     &             3,ONE)
        ENDIF
C
C FORM PRODUCT:
C 
C            G(A<B,CI) = RTAU(A<B,M<N)*Q(M<N,CI) [ISPIN=1 OR 2]
C            G(Ab,Ic)  = RTAU(Ab,Mn)*Q(Mn,Ic)    [ISPIN=3]
C            G(Ab,Ci)  = RTAU(Ab,Mn)*Q(Mn,Ci)    [ISPIN=4]
C
        MXCOR=MAXCOR-I020+1
        NINCOR=MXCOR/(IINTFP*MAX(1,DISSYG))
        NLEFT=NUMDSG
        IFIRST=1
        IOFFQ=I010
1       NREAD=MIN(NLEFT,NINCOR)
        CALL GETLST(ICORE(I020),IFIRST,NREAD,1,IRREPL,LISTG)
        CALL XGEMM('N','N',DISSYG,NREAD,NUMDSR,HALFM,ICORE(I000),
     &             DISSYG,ICORE(IOFFQ),NUMDSR,ONE,ICORE(I020),
     &             DISSYG)
        CALL PUTLST(ICORE(I020),IFIRST,NREAD,1,IRREPL,LISTG)
        IOFFQ=IOFFQ+IINTFP*NREAD*NUMDSR
        NLEFT=NLEFT-NREAD
        IFIRST=IFIRST+NREAD
        IF(NLEFT.NE.0)GOTO 1
C
100    CONTINUE
C
10    CONTINUE
C
C ALL DONE, RETURN
C
C
      TWO=0.D0
      if(iuhf.eq.0) then
       call checkgam1(icore,30,130,two,iuhf,2,vrt)
      endif
      IF(IUHF.EQ.1) THEN
       CALL CHECKGAM(ICORE,30,130,TWO)
       CALL CHECKGAM(ICORE,27,127,TWO)
       CALL CHECKGAM(ICORE,28,128,TWO)
       CALL CHECKGAM(ICORE,29,129,TWO)
      ENDIF
      RETURN
      END
