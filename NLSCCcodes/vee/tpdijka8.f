      SUBROUTINE TPDIJKA8(ICORE,MAXCOR,IUHF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL MBPT2,CC,CCD,RCCD,DRCCD,LCCD,LCCSD,CC2
      INTEGER DIRPRD,DISSYG,DISSYL,DISSYT,POP,VRT
      DIMENSION ICORE(MAXCOR)
      DIMENSION I0T(2),I0RL(2),I0R(2)
C
C CALCULATION OF THE FIRST IJKA CONTRIBUTION TO
C THE EOM-CCSD TWO-PARTICLE DENSITY MATRIX
C
C          - 1/2 TAU(IJ,EA) L(KN,EF) R(N,F)
C
CEND 
C
C CODED JG SEPTEMBER/93
C
      COMMON/STATSYM/IRREPX
      COMMON/REFTYPE/MBPT2,CC,CCD,RCCD,DRCCD,LCCD,LCCSD,CC2
      COMMON/SYMINF/NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
C
      DATA AZERO,HALF,HALFM,ONE,ONEM,TWO
     &       /0.D0,0.5D0,-0.5D0,1.0D0,-1.D0,2.0D0/
C
      IF(MBPT2 .OR. LCCD .OR. LCCSD .OR. RCCD .OR. DRCCD .OR. CC2)
     &   GOTO 5000
C
C READ IN T1, R1, AND L1 AMPLITUDES
C
      I0RL(1)=1
      I0RL(2)=I0RL(1)+IRPDPD(1,9)*IINTFP*IUHF
      I0T(1)=I0RL(2)+IRPDPD(1,10)*IINTFP
      I0T(2)=I0T(1)+IRPDPD(1,9)*IINTFP*IUHF
      I0R(1)=I0T(2)+IRPDPD(1,10)*IINTFP
      I0R(2)=I0R(1)+IRPDPD(IRREPX,9)*IINTFP*IUHF
      ISTART=I0R(2)+IRPDPD(IRREPX,10)*IINTFP
C
      CALL GETLST(ICORE(I0R(1)),1,1,1,3,490)
      CALL GETLST(ICORE(I0T(1)),1,1,1,1,90)
      IF(IUHF.EQ.1) THEN
       CALL GETLST(ICORE(I0R(2)),1,1,1,4,490)
       CALL GETLST(ICORE(I0T(2)),1,1,1,2,90)
      ENDIF
C
C AAAA AND BBBB SPIN CASES (UHF ONLY)
C
      IF(IUHF.EQ.1) THEN
C
       DO 1 ISPIN=1,2
C
        LISTL=433+ISPIN
C
        NUMSYL=IRPDPD(1,ISYTYP(2,LISTL))
        DISSYL=IRPDPD(IRREPX,ISYTYP(1,LISTL))
C
        I000=ISTART
        IEND=ISTART+IINTFP*NUMSYL*DISSYL
        IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA8',IEND,MAXCOR)
C
        CALL GETLST(ICORE(I000),1,NUMSYL,1,1,LISTL) 
C
        CALL XGEMM('N','N',1,NUMSYL,DISSYL,ONEM,ICORE(I0R(ISPIN)),1,
     &             ICORE(I000),DISSYL,AZERO,ICORE(I0RL(ISPIN)),1) 
C
        LISTL=435+ISPIN
C
        NUMSYL=IRPDPD(1,ISYTYP(2,LISTL))
        DISSYL=IRPDPD(IRREPX,ISYTYP(1,LISTL))
C
        I000=ISTART
        IEND=ISTART+IINTFP*NUMSYL*DISSYL
        IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA8',IEND,MAXCOR)
C
        CALL GETLST(ICORE(I000),1,NUMSYL,1,1,LISTL) 
C
        CALL XGEMM('N','N',1,NUMSYL,DISSYL,ONE,ICORE(I0R(3-ISPIN)),1,
     &             ICORE(I000),DISSYL,ONE,ICORE(I0RL(ISPIN)),1) 
C
1     CONTINUE
C
      ELSE
C
       LISTL1=437
       LISTL2=439
C
       NUMSYL=IRPDPD(1,ISYTYP(2,LISTL1))
       DISSYL=IRPDPD(IRREPX,ISYTYP(1,LISTL1))
C
       I000=ISTART
       I010=I000+IINTFP*NUMSYL*DISSYL
       IEND=I010+IINTFP*NUMSYL*DISSYL
C
       CALL GETLST(ICORE(I000),1,NUMSYL,1,1,LISTL1)
       CALL GETLST(ICORE(I010),1,NUMSYL,1,1,LISTL2)
C
       CALL SSCAL(NUMSYL*DISSYL,TWO,ICORE(I000),1)
       CALL SAXPY(NUMSYL*DISSYL,ONEM,ICORE(I010),1,ICORE(I000),1)
C
       CALL XGEMM('N','N',1,NUMSYL,DISSYL,ONE,ICORE(I0R(1)),1,
     &            ICORE(I000),DISSYL,AZERO,ICORE(I0RL(1)),1)
C
      ENDIF
C 
      IF(IUHF.EQ.1) THEN
C
       DO 1000 ISPIN=1,2
C
        LISTG=106+ISPIN
        LISTT=43+ISPIN
C
        DO 100 IRREP=1,NIRREP
C
         NUMSYG=IRPDPD(IRREP,ISYTYP(2,LISTG)) 
         DISSYG=IRPDPD(IRREP,ISYTYP(1,LISTG))
         NUMSYT=IRPDPD(IRREP,ISYTYP(2,LISTT))
         DISSYT=IRPDPD(IRREP,ISYTYP(1,LISTT))
         NVRTSQ=IRPDPD(IRREP,18+ISPIN)
C
C ALLOCATE MEMORY
C
         I000=ISTART
         I010=I000+IINTFP*NUMSYG*DISSYG
         I020=I010+IINTFP*MAX(NUMSYT*NVRTSQ,DISSYG*NUMSYG)
         ITMP=I020+IINTFP*NUMSYT*DISSYT
         IEND=ITMP+IINTFP*3*MAX(DISSYG,DISSYT,NUMSYG,NUMSYT)
         IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA8',IEND,MAXCOR)
C
C GET T AMPLITUDES
C
         CALL GETLST(ICORE(I020),1,NUMSYT,1,IRREP,LISTT)
C
         CALL FTAU(ICORE(I020),ICORE(I0T(ISPIN)),
     &             ICORE(I0T(ISPIN)),DISSYT,NUMSYT,
     &             POP(1,ISPIN),POP(1,ISPIN),VRT(1,ISPIN),
     &             VRT(1,ISPIN),IRREP,ISPIN,ONE)
C
C TRANSPOSE TAU
C
         CALL TRANSP(ICORE(I020),ICORE(I010),NUMSYT,DISSYT)
C
C EXPAND RIGHT-HAND SIDE OF L AMPLITUDES
C
         CALL SYMEXP(IRREP,VRT(1,ISPIN),NUMSYT,ICORE(I010))
C
C PERFORM MULTIPLICATION
C
         IOFFT=0
         IOFFRL=0
         IOFFG=0
C
         DO 10 IRREPE=1,NIRREP
          IRREPA=DIRPRD(IRREP,IRREPE)
          NVRTA=VRT(IRREPA,ISPIN)
          NVRTE=VRT(IRREPE,ISPIN)
          NOCCI=POP(IRREPE,ISPIN)
C
C
          CALL XGEMM('N','N',NUMSYT*NVRTA,NOCCI,NVRTE,HALF,
     &               ICORE(I010+IOFFT),NUMSYT*NVRTA,
     &               ICORE(I0RL(ISPIN)+IOFFRL),NVRTE,AZERO,
     &               ICORE(I000+IOFFG),DISSYG*NVRTA) 
C
          IOFFT=IOFFT+IINTFP*NUMSYT*NVRTA*NVRTE
          IOFFRL=IOFFRL+IINTFP*NOCCI*NVRTE
          IOFFG=IOFFG+IINTFP*DISSYG*NVRTA*NOCCI
C
10       CONTINUE
C
C TRANSPOSE THIRD AND FOURTH INDEX TO GET G(IJ,KA)
C
         CALL SYMTR1(IRREP,VRT(1,ISPIN),POP(1,ISPIN),
     &               DISSYG,ICORE(I000),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYG),
     &               ICORE(ITMP+2*IINTFP*DISSYG))
C
C SAVE G(IJ,KA) ON DISK   (UPDATE ???)
C
          call checksum('tpdijka8',icore(i000),numsyg*dissyg,s)
         CALL GETLST(ICORE(I010),1,NUMSYG,1,IRREP,LISTG)
         CALL SAXPY (NUMSYG*DISSYG,ONE,ICORE(I010),1,ICORE(I000),1)
         CALL PUTLST(ICORE(I000),1,NUMSYG,1,IRREP,LISTG)
C
100     CONTINUE
C
1000   CONTINUE
C
      ENDIF
C
C ABAB AND BABA SPIN CASE
C
      DO 2000 ISPIN=1,IUHF+1
C
       LISTG=111-ISPIN
       LISTT=46
C
       DO 1100 IRREP=1,NIRREP
C
        NUMSYG=IRPDPD(IRREP,ISYTYP(2,LISTG)) 
        DISSYG=IRPDPD(IRREP,ISYTYP(1,LISTG))
        NUMSYT=IRPDPD(IRREP,ISYTYP(2,LISTT))
        DISSYT=IRPDPD(IRREP,ISYTYP(1,LISTT))
C
C ALLOCATE MEMORY
C
        I000=ISTART
        I010=I000+IINTFP*NUMSYG*DISSYG
        I020=I010+IINTFP*MAX(NUMSYT*DISSYT,NUMSYG*DISSYG)
        ITMP=I020+IINTFP*NUMSYT*DISSYT
        IEND=ITMP+IINTFP*3*MAX(DISSYT,NUMSYT,DISSYG,NUMSYG)
        IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA8',IEND,MAXCOR)
C
C GET T AMPLITUDES
C
         CALL GETLST(ICORE(I020),1,NUMSYT,1,IRREP,LISTT)
C
         CALL FTAU(ICORE(I020),ICORE(I0T(1)),
     &             ICORE(I0T(2)),DISSYT,NUMSYT,
     &             POP(1,1),POP(1,2),VRT(1,1),
     &             VRT(1,2),IRREP,3,ONE)
C
         CALL TRANSP(ICORE(I020),ICORE(I010),NUMSYT,DISSYT)
C
C FOR ISPIN=1 INTERCHANGE A AND B
C
        IF(ISPIN.EQ.1) THEN
         CALL SYMTR1(IRREP,VRT(1,1),VRT(1,2),NUMSYT,ICORE(I010),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYT),
     &               ICORE(ITMP+2*IINTFP*NUMSYT))
        ENDIF
C
C PERFORM MULTIPLICATION
C
        IOFFT=0
        IOFFRL=0
        IOFFG=0
C
        DO 110 IRREPE=1,NIRREP
         IRREPA=DIRPRD(IRREP,IRREPE)
         NVRTA=VRT(IRREPA,3-ISPIN)
         NVRTE=VRT(IRREPE,ISPIN)
         NOCCI=POP(IRREPE,ISPIN)
C
         CALL XGEMM('N','N',NUMSYT*NVRTA,NOCCI,NVRTE,HALFM,
     &              ICORE(I010+IOFFT),NUMSYT*NVRTA,
     &              ICORE(I0RL(ISPIN)+IOFFRL),NVRTE,AZERO,
     &              ICORE(I000+IOFFG),DISSYG*NVRTA) 
C
         IOFFT=IOFFT+IINTFP*NUMSYT*NVRTA*NVRTE
         IOFFG=IOFFG+IINTFP*DISSYG*NVRTA*NOCCI
         IOFFRL=IOFFRL+IINTFP*NVRTE*NOCCI
C
110     CONTINUE
C
C TRANSPOSE THIRD AND FOURTH INDEX TO GET G(JK,IA) (ONLY FOR ISPIN=1)
C
        IF(ISPIN.EQ.1) THEN
         CALL SYMTR1(IRREP,VRT(1,2),POP(1,1),DISSYG,ICORE(I000),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYG),
     &               ICORE(ITMP+2*IINTFP*DISSYG))
        ENDIF
C
C SAVE G(IJ,KA) ON DISK   (OR UPDATE ???)
C
        call checksum('tpdijka8',icore(i000),numsyg*dissyg,s)
        CALL GETLST(ICORE(I010),1,NUMSYG,1,IRREP,LISTG)
        CALL SAXPY (NUMSYG*DISSYG,ONE,ICORE(I010),1,ICORE(I000),1)
        CALL PUTLST(ICORE(I000),1,NUMSYG,1,IRREP,LISTG)
C
1100   CONTINUE
C
2000  CONTINUE
C
C ALL DONE, RETURN
C
5000  CONTINUE
      TWO=4.D0/DFLOAT(1+IUHF)
      if(iuhf.eq.0) then
       call checkgam1(icore,10,110,two,iuhf,2,pop)
      endif
      IF(IUHF.EQ.1) THEN
       CALL CHECKGAM(ICORE,10,110,TWO)
       CALL CHECKGAM(ICORE,7,107,TWO)
       CALL CHECKGAM(ICORE,8,108,TWO)
       CALL CHECKGAM(ICORE,9,109,TWO)
      ENDIF
C
      RETURN
      END
