
      SUBROUTINE TPDIJKA3(ICORE,MAXCOR,IUHF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL  MBPT2,CC,CCD,RCCD,DRCCD,LCCD,LCCSD,CC2
      INTEGER DIRPRD,DISSYG,DISSYL,DISSYT,POP,VRT
      DIMENSION ICORE(MAXCOR)
      DIMENSION I0T(2),I0R(2)
      DIMENSION IOFFRR(8,2),IOFFGG(8)
C
C CALCULATION OF THE SECOND IJKA CONTRIBUTION TO
C THE EOM-CCSD TWO-PARTICLE DENSITY MATRIX
C
C G(IJ,KA) =  1/2  R(M,A) 1/2 TAU(IJ,EF) L(KM,EF)
C
C ALSO, ONLY THE SUM OF G(IJ,KA) AND G(IA,JK) IS STORED ON DISK
C
CEND 
C
C CODED JG SEPTEMBER/93
C
      COMMON/STATSYM/IRREPX
      COMMON/SYMINF/NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /REFTYPE/ MBPT2,CC,CCD,RCCD,DRCCD,LCCD,LCCSD,CC2
C
      DATA AZERO,HALF,ONE /0.D0,0.5D0,1.0D0/
C
C READ IN T1, R1, AND L1 AMPLITUDES
C
      I0T(1)=1
      I0T(2)=I0T(1)+IRPDPD(1,9)*IINTFP*IUHF
      I0R(1)=I0T(2)+IRPDPD(1,10)*IINTFP
      I0R(2)=I0R(1)+IRPDPD(IRREPX,9)*IINTFP*IUHF
      ISTART=I0R(2)+IRPDPD(IRREPX,10)*IINTFP
C
      CALL GETLST(ICORE(I0R(1)),1,1,1,3,490)
      CALL GETLST(ICORE(I0T(1)),1,1,1,1,90)
      IF(IUHF.EQ.1) THEN
       CALL GETLST(ICORE(I0R(2)),1,1,1,4,490)
       CALL GETLST(ICORE(I0T(2)),1,1,1,2,90)
      ENDIF
C
      DO 10 ISPIN=1,1+IUHF
       IOFF=0
       DO 11 IRREPR=1,NIRREP
        IRREPL=DIRPRD(IRREPR,IRREPX)
        IOFFRR(IRREPR,ISPIN)=IOFF
        IOFF=IOFF+IINTFP*POP(IRREPR,ISPIN)*VRT(IRREPL,ISPIN)
11     CONTINUE
10    CONTINUE
      IF(IUHF.EQ.0) CALL ICOPY(8,IOFFRR(1,1),1,IOFFRR(1,2),1)
C
C LOOP OVER SPIN CASES
C
      DO 1000 ISPIN=3-2*IUHF,3
C
C LOOP OVER IRREPS
C
       DO 100 IRREPR=1,NIRREP
C
        IRREPL=DIRPRD(IRREPR,IRREPX) 
C
C GET R(TWIDDLE)
C
        LISTT=43+ISPIN
        LISTL=443+ISPIN
C
        NUMSYT=IRPDPD(IRREPL,ISYTYP(2,LISTT))
        DISSYT=IRPDPD(IRREPL,ISYTYP(1,LISTT))
        NUMSYL=IRPDPD(IRREPR,ISYTYP(2,LISTL))
        DISSYL=IRPDPD(IRREPL,ISYTYP(1,LISTL))
C
C  ALLOCATE MEMORY
C
        I000=ISTART
        I010=I000+IINTFP*NUMSYT*NUMSYL
        I020=I010+IINTFP*NUMSYT*DISSYT
        IEND=I020+IINTFP*NUMSYL*DISSYL
        IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA3',IEND,MAXCOR)
C
C GET T AMPLITUDE
C
        IF (CC2) THEN
           CALL ZERO(ICORE(I010),NUMSYT*DISSYT)
        ELSE
           CALL GETLST(ICORE(I010),1,NUMSYT,1,IRREPL,LISTT)
        ENDIF 
C
C FORM TAU AMPLITUDES
C
        IF(ISPIN.LE.2) THEN
         CALL FTAU(ICORE(I010),ICORE(I0T(ISPIN)),ICORE(I0T(ISPIN)),
     &            DISSYT,NUMSYT,POP(1,ISPIN),POP(1,ISPIN),
     &             VRT(1,ISPIN),VRT(1,ISPIN),IRREPL,ISPIN,ONE)
        ELSE
         CALL FTAU(ICORE(I010),ICORE(I0T(1)),ICORE(I0T(2)),
     &             DISSYT,NUMSYT,POP(1,1),POP(1,2),
     &             VRT(1,1),VRT(1,2),IRREPL,ISPIN,ONE)
        ENDIF
C
C GET L AMPLITUDES
C
        CALL GETLST(ICORE(I020),1,NUMSYL,1,IRREPR,LISTL)
C
C PERFORM MULTIPLICATION
C
        CALL XGEMM('T','N',NUMSYT,NUMSYL,DISSYT,ONE,ICORE(I010),
     &             DISSYT,ICORE(I020),DISSYL,AZERO,ICORE(I000),
     &             NUMSYT)       
C
C MULTIPLY  TAU*L WITH R1
C
        IF(ISPIN.LE.2) THEN
C
C SPIN CASES AAAA AND BBBB
C
         LISTG=106+ISPIN
C
         NUMSYG=IRPDPD(IRREPL,ISYTYP(2,LISTG))
         DISSYG=IRPDPD(IRREPL,ISYTYP(1,LISTG))
C
         IOFF=0
         DO 140 IRREPRR=1,NIRREP
          IRREPRL=DIRPRD(IRREPRR,IRREPL)
          IOFFGG(IRREPRR)=IOFF
          IOFF=IOFF+IINTFP*DISSYG*POP(IRREPRL,ISPIN)*VRT(IRREPRR,ISPIN)
140      CONTINUE
C
         NOCCSQ=IRPDPD(IRREPR,20+ISPIN)
         I010=I000+IINTFP*NUMSYT*NOCCSQ
         IEND=I010+IINTFP*NUMSYG*DISSYG
         IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA3',IEND,MAXCOR) 
C
C EXPAND FIRST RIGHT-HAND SIDE OF T*L PRODUCT
C
         CALL SYMEXP(IRREPR,POP(1,ISPIN),NUMSYT,ICORE(I000))
C
C PERFORM MULTIPLICATION
C 
         IOFFRL=0
C
         DO 150 IRREPRR=1,NIRREP
          IRREPRL=DIRPRD(IRREPR,IRREPRR)
          IRREPRRR=DIRPRD(IRREPRR,IRREPX)
          NVRTA=VRT(IRREPRRR,ISPIN)
          NOCCM=POP(IRREPRR,ISPIN)
          NOCCK=POP(IRREPRL,ISPIN)
C
          IOFFR=IOFFRR(IRREPRR,ISPIN)
          IOFFG=IOFFGG(IRREPRRR)
C
          CALL XGEMM('N','T',NUMSYT*NOCCK,NVRTA,NOCCM,HALF,
     &              ICORE(I000+IOFFRL),NUMSYT*NOCCK,
     &              ICORE(I0R(ISPIN)+IOFFR),NVRTA,AZERO,
     &              ICORE(I010+IOFFG),NUMSYT*NOCCK)
C
C UPDATE OFFSETS
C
          IOFFRL=IOFFRL+IINTFP*NOCCK*NOCCM*NUMSYT
C
150      CONTINUE
C
C SAVE G(IJ,KA) ON DISK   (UPDATE ????)
C
         I020=I010+IINTFP*NUMSYG*DISSYG
         IEND=I020+IINTFP*NUMSYG*DISSYG
         IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA3',IEND,MAXCOR)
         CALL GETLST(ICORE(I020),1,NUMSYG,1,IRREPL,LISTG)
         CALL SAXPY(NUMSYG*DISSYG,ONE,ICORE(I020),1,ICORE(I010),1)
         call checksum('tpdijka3',icore(i010),numsyg*dissyg,s)
         CALL PUTLST(ICORE(I010),1,NUMSYG,1,IRREPL,LISTG)
C
        ELSE
C
C SPIN CASES ABAB AND BABA
C
         DO 250 ISPIN2=1,1+IUHF
C
          LISTG=111-ISPIN2
C
          NUMSYG=IRPDPD(IRREPL,ISYTYP(2,LISTG))
          DISSYG=IRPDPD(IRREPL,ISYTYP(1,LISTG))
          I010=I000+IINTFP*NUMSYT*NUMSYL
          ITMP=I010+IINTFP*NUMSYG*DISSYG
          IEND=ITMP+3*MAX(DISSYG,NUMSYG,NUMSYT,NUMSYL)
          IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA3',IEND,MAXCOR) 
    
          IF(ISPIN2.EQ.1) THEN
           IS1=1
           IS2=2
          ELSE
           IS1=2
           IS2=1
           CALL SYMTR1(IRREPR,POP(1,1),POP(1,2),NUMSYT,ICORE(I000),
     &                 ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYT),
     &                 ICORE(ITMP+2*IINTFP*NUMSYT))
          ENDIF
          IOFF=0
          DO 1140 IRREPRR=1,NIRREP
           IRREPRL=DIRPRD(IRREPRR,IRREPL)
           IOFFGG(IRREPRR)=IOFF
           IOFF=IOFF+IINTFP*DISSYG*
     &     POP(IRREPRL,IS1)*VRT(IRREPRR,IS2)
1140      CONTINUE
C
C PERFORM MULTIPLICATION
C
          IOFFRL=0
C
          DO 240 IRREPRR=1,NIRREP
           IRREPRL=DIRPRD(IRREPR,IRREPRR)
           IRREPRRR=DIRPRD(IRREPRR,IRREPX)
           NVRTA=VRT(IRREPRRR,IS2)
           NOCCM=POP(IRREPRR,IS2)
           NOCCK=POP(IRREPRL,IS1)
C
           IOFFR=IOFFRR(IRREPRR,IS2)
           IOFFG=IOFFGG(IRREPRRR)
C
           CALL XGEMM('N','T',NUMSYT*NOCCK,NVRTA,NOCCM,HALF,
     &                ICORE(I000+IOFFRL),NUMSYT*NOCCK,
     &                ICORE(I0R(IS2)+IOFFR),NVRTA,AZERO,
     &                ICORE(I010+IOFFG),NUMSYT*NOCCK)
C
C UPDATE OFFSETS
C
           IOFFRL=IOFFRL+IINTFP*NOCCK*NOCCM*NUMSYT
C
240       CONTINUE
C
          IF(ISPIN2.EQ.2) THEN
           CALL SYMTR1(IRREPL,POP(1,2),VRT(1,1),NUMSYT,ICORE(I010),
     &                 ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYT),
     &                 ICORE(ITMP+2*IINTFP*NUMSYT))
          ENDIF
C
C SAVE G(IJ,KA) ON DISK  (UPDATE ????)
C
          I020=I010+IINTFP*NUMSYG*DISSYG
          IEND=I020+IINTFP*NUMSYG*DISSYG
          IF(IEND.GE.MAXCOR) CALL INSMEM('TPDIJKA3',IEND,MAXCOR)
          CALL GETLST(ICORE(I020),1,NUMSYG,1,IRREPL,LISTG)
          CALL SAXPY(NUMSYG*DISSYG,ONE,ICORE(I020),1,ICORE(I010),1)
          call checksum('tpdijka3',icore(i010),numsyg*dissyg,s)
          CALL PUTLST(ICORE(I010),1,NUMSYG,1,IRREPL,LISTG)
C
250      CONTINUE 
C
        ENDIF
C
100    CONTINUE
C
1000  CONTINUE
C
C ALL DONE, RETURN
C
C
      TWO=0.D0
      if(iuhf.eq.0) then
       call checkgam1(icore,10,110,two,iuhf,2,pop,s)
      endif
      IF(IUHF.EQ.1) THEN
       CALL CHECKGAM(ICORE,10,110,TWO)
       CALL CHECKGAM(ICORE,7,107,TWO)
       CALL CHECKGAM(ICORE,8,108,TWO)
       CALL CHECKGAM(ICORE,9,109,TWO)
      ENDIF
C
      RETURN
      END
